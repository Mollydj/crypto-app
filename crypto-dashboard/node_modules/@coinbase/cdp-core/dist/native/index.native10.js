import { b as m } from "./index.native38.js";
import { configureCdpApiClient as T, setAuthManager as b, authenticateUserWithCustomAuth as j, initiateAuthentication as P, createEndUserEvmAccount as x, createEndUserEvmSmartAccount as k, createEndUserSolanaAccount as K, verifyEmailAuthentication as W, verifySmsAuthentication as H, verifyOAuthCode as R, signEvmHashWithEndUserAccount as B, signEvmTransactionWithEndUserAccount as D, signSolanaTransactionWithEndUserAccount as N, sendEvmTransactionWithEndUserAccount as F, sendSolanaTransactionWithEndUserAccount as J, signEvmMessageWithEndUserAccount as L, signSolanaMessageWithEndUserAccount as z, signEvmTypedDataWithEndUserAccount as $, sendUserOperationWithEndUserAccount as V, getUserOperationWithEndUserAccount as q, exportEndUserEvmAccount as G, exportEndUserSolanaAccount as Q } from "@coinbase/cdp-api-client";
import { Analytics as c } from "./index.native2.js";
import "./index.native3.js";
import { Keypair as E } from "@solana/web3.js";
import S from "bs58";
import { createAuthManager as X } from "./index.native39.js";
import { CUSTOM_AUTH_REFRESH_BUFFER_MS as Y } from "./index.native40.js";
import { OAuthManager as Z } from "./index.native41.js";
import { toAuthState as g } from "./index.native42.js";
import { withAuth as d } from "./index.native43.js";
import { MockAuthManager as ee } from "./index.native44.js";
import { MockOAuthManager as te } from "./index.native45.js";
import { mockUser as p } from "./index.native46.js";
import { getPlatformServices as f, getPlatformCrypto as U } from "./index.native8.js";
import { isChainSupportedForCDPSends as ne } from "./index.native47.js";
import { getConfig as a, setCoreAuthManager as I, setCoreOAuthManager as _, getCoreAuthManager as o, getCoreOAuthManager as re, setConfig as se } from "./index.native37.js";
import { CustomAuthError as w } from "./index.native31.js";
import { serializeTransaction as C } from "./index.native48.js";
const _e = async (e) => {
  if (!e.projectId)
    throw new Error("Project ID is required");
  e.disableAnalytics === void 0 || e.disableAnalytics === !1 ? (c.identifier = e.projectId, c.isUsingMocks = e.useMock === !0, c.isProduction = !e.basePath || e.basePath === "https://api.cdp.coinbase.com/platform") : c.enabled = !1;
  let n;
  try {
    n = a().projectId !== e.projectId;
  } catch {
    n = !0;
  }
  if (se(e), a().useMock) {
    I(new ee(a().projectId)), _(new te());
    return;
  }
  let t;
  try {
    const r = f();
    t = r.secureStorage ? {
      getRefreshToken: () => r.secureStorage.getItem("cdp_refresh_token"),
      setRefreshToken: (s) => r.secureStorage.setItem("cdp_refresh_token", s),
      removeRefreshToken: () => r.secureStorage.removeItem("cdp_refresh_token")
    } : (
      // This is used only in WebKit browsers by virtue of the API
      {
        getRefreshToken: () => r.storage.getItem("cdp_refresh_token"),
        setRefreshToken: (s) => r.storage.setItem("cdp_refresh_token", s),
        removeRefreshToken: () => r.storage.removeItem("cdp_refresh_token")
      }
    );
  } catch {
    t = void 0;
  }
  if (T({
    debugging: a().debugging,
    basePath: a().basePath,
    refreshTokenStorage: t
  }), n) {
    const r = new Z();
    _(r);
    const s = X(a().projectId);
    I(s), b(s);
  }
  await o().ensureInitialized();
}, Ue = async (e) => (c.sendActionCallEvent({ name: "sign_in_with_email" }), y({
  email: e.email,
  type: "email"
})), Ce = async (e) => (c.sendActionCallEvent({ name: "sign_in_with_sms" }), y({
  phoneNumber: e.phoneNumber,
  type: "sms"
})), Me = async (e) => {
  c.sendActionCallEvent({ name: "sign_in_with_oauth" });
  const n = f().oauth.getRedirectUrl();
  if (a().useMock) {
    const r = new URL(n);
    r.searchParams.set("code", "mock-oauth-code"), r.searchParams.set("provider_type", e), r.searchParams.set("flow_id", "mock-flow-id"), f().oauth.initiateOAuthFlow(r.toString());
    return;
  }
  const { authUrl: t } = await y({
    redirectUrl: n,
    type: e
  });
  f().oauth.initiateOAuthFlow(t);
}, Oe = async (e) => (c.sendActionCallEvent({ name: "verify_email_otp" }), A(
  e,
  "Mock email OTP verified",
  (n, t) => W(n, t)
)), Te = async (e) => (c.sendActionCallEvent({ name: "verify_sms_otp" }), A(
  e,
  "Mock SMS OTP verified",
  (n, t) => H(n, t)
)), be = async (e) => (c.sendActionCallEvent({ name: "verify_oauth" }), A(
  e,
  "Mock OAuth code verified",
  (n, t) => R(n, t.providerType, t)
)), je = async () => {
  c.sendActionCallEvent({ name: "authenticate_with_jwt" });
  const e = a();
  if (!e.customAuth?.getJwt)
    throw new w(
      "customAuth.getJwt callback not configured. Please provide customAuth with getJwt in initialize() config."
    );
  let n;
  try {
    n = await e.customAuth.getJwt();
  } catch (u) {
    throw new w(
      u instanceof Error ? u.message : "Failed to get custom auth JWT"
    );
  }
  if (!n)
    throw new w("customAuth.getJwt returned null or undefined");
  if (e.useMock)
    return await o().setAuthState({
      accessToken: n,
      expiresAt: Date.now() + 1e3 * 60 * 60 * 24,
      user: p
    }), {
      message: "Mock JWT authentication successful",
      user: p,
      isNewUser: !1
    };
  const t = await j(a().projectId), r = new Date(Date.now() + Y).toISOString();
  let s = g(n, r, t.endUser);
  return await o().setAuthState(s), e.ethereum?.createOnLogin && (s = await M(
    s,
    n,
    r,
    e.ethereum.createOnLogin
  )), e.solana?.createOnLogin && (s = await O(s, n, r)), {
    message: "Authentication successful",
    user: o().getUser(),
    isNewUser: t.isNewEndUser
  };
}, Pe = async () => (c.sendActionCallEvent({ name: "get_current_user" }), o().getUser()), xe = async () => (c.sendActionCallEvent({ name: "is_signed_in" }), o().isSignedIn()), Ke = async () => {
  if (c.sendActionCallEvent({ name: "sign_out" }), a().useMock) {
    await o().signOut();
    return;
  }
  if (!await o().isSignedIn())
    throw new Error("User not signed in");
  await o().signOut();
}, We = async (e = { forceRefresh: !1 }) => (c.sendActionCallEvent({ name: "get_access_token" }), o().getToken(e)), He = async () => (c.sendActionCallEvent({ name: "get_access_token_expiration" }), o().getTokenExpiration()), Re = (e) => {
  o().addAuthStateChangeCallback(e);
}, Be = (e) => {
  re().addOAuthStateChangeCallback(e);
}, De = async (e) => (c.sendActionCallEvent({ name: "sign_evm_hash" }), a().useMock ? { signature: "0x0" } : d(e, o(), async ({ user: n, walletSecretId: t }) => ({
  signature: (await B(a().projectId, n.userId, {
    hash: e.hash,
    address: e.evmAccount,
    walletSecretId: t
  })).signature
}))), Ne = async (e) => (c.sendActionCallEvent({ name: "sign_evm_transaction" }), a().useMock ? { signedTransaction: "0x0" } : d(e, o(), async ({ user: n, walletSecretId: t }) => {
  const r = C(e.transaction);
  return {
    signedTransaction: (await D(
      a().projectId,
      n.userId,
      {
        transaction: r,
        address: e.evmAccount,
        walletSecretId: t
      }
    )).signedTransaction
  };
})), Fe = async (e) => (c.sendActionCallEvent({ name: "sign_solana_transaction" }), a().useMock ? { signedTransaction: "mock-signed-transaction" } : d(e, o(), async ({ user: n, walletSecretId: t }) => ({
  signedTransaction: (await N(
    a().projectId,
    n.userId,
    {
      transaction: e.transaction,
      address: e.solanaAccount,
      walletSecretId: t
    }
  )).signedTransaction
}))), Je = async (e) => {
  if (c.sendActionCallEvent({ name: "send_evm_transaction" }), !ne(e.network))
    throw new Error(`Chain ${e.network} is not supported by the CDP Apis`);
  if (a().useMock)
    return { transactionHash: "0x0" };
  const n = C(e.transaction);
  return d(e, o(), async ({ user: t, walletSecretId: r }) => ({
    transactionHash: (await F(
      a().projectId,
      t.userId,
      {
        transaction: n,
        address: e.evmAccount,
        walletSecretId: r,
        network: e.network
      }
    )).transactionHash
  }));
}, Le = async (e) => (c.sendActionCallEvent({ name: "send_solana_transaction" }), a().useMock ? { transactionSignature: "mock-signature" } : d(e, o(), async ({ user: n, walletSecretId: t }) => ({
  transactionSignature: (await J(
    a().projectId,
    n.userId,
    {
      transaction: e.transaction,
      address: e.solanaAccount,
      walletSecretId: t,
      network: e.network
    }
  )).transactionSignature
}))), ze = async (e) => (c.sendActionCallEvent({ name: "sign_evm_message" }), a().useMock ? { signature: "0x0" } : d(e, o(), async ({ user: n, walletSecretId: t }) => ({
  signature: (await L(a().projectId, n.userId, {
    message: e.message,
    address: e.evmAccount,
    walletSecretId: t
  })).signature
}))), $e = async (e) => (c.sendActionCallEvent({ name: "sign_solana_message" }), a().useMock ? { signature: "mockSignature" } : d(e, o(), async ({ user: n, walletSecretId: t }) => ({
  signature: (await z(a().projectId, n.userId, {
    message: e.message,
    address: e.solanaAccount,
    walletSecretId: t
  })).signature
}))), Ve = async (e) => (c.sendActionCallEvent({ name: "sign_evm_typed_data" }), a().useMock ? { signature: "0x0" } : d(e, o(), async ({ user: n, walletSecretId: t }) => ({
  signature: (await $(a().projectId, n.userId, {
    typedData: e.typedData,
    address: e.evmAccount,
    walletSecretId: t
  })).signature
}))), qe = async (e) => (c.sendActionCallEvent({ name: "send_user_operation" }), a().useMock ? {
  userOperationHash: "0x1234567890123456789012345678901234567890123456789012345678901234"
} : d(e, o(), async ({ user: n, walletSecretId: t }) => ({
  userOperationHash: (await V(
    a().projectId,
    n.userId,
    e.evmSmartAccount,
    {
      network: e.network,
      calls: e.calls.map((s) => ({
        to: s.to,
        value: String(s.value ?? 0n),
        data: s.data ?? "0x"
      })),
      walletSecretId: t,
      useCdpPaymaster: e.useCdpPaymaster ?? !1,
      paymasterUrl: e.paymasterUrl,
      dataSuffix: e.dataSuffix
    }
  )).userOpHash
}))), Ge = async (e) => (c.sendActionCallEvent({ name: "get_user_operation" }), a().useMock ? {
  userOpHash: e.userOperationHash,
  network: e.network,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: "0",
      data: "0x"
    }
  ],
  status: "complete",
  transactionHash: "0x9876543210987654321098765432109876543210987654321098765432109876",
  receipts: []
} : d(e, o(), async ({ user: n }) => await q(
  a().projectId,
  n.userId,
  e.evmSmartAccount,
  e.userOperationHash
))), Qe = async (e) => {
  if (c.sendActionCallEvent({ name: "export_evm_account" }), a().useMock)
    return {
      privateKey: m.Buffer.from("mock-private-key").toString("hex")
    };
  const n = U(), t = await n.createExportKeyPair();
  return d(e, o(), async ({ user: r, walletSecretId: s }) => {
    const i = await G(a().projectId, r.userId, {
      address: e.evmAccount,
      walletSecretId: s,
      exportEncryptionKey: t.publicKeyBase64
    }), u = await n.decryptWithPrivateKey(
      t.privateKey,
      i.encryptedPrivateKey
    );
    return {
      privateKey: m.Buffer.from(u).toString("hex")
    };
  });
}, Xe = async (e) => {
  if (c.sendActionCallEvent({ name: "export_solana_account" }), a().useMock) {
    const r = m.Buffer.from("mock-private-key").subarray(0, 32), s = m.Buffer.alloc(32);
    r.copy(s);
    const i = E.fromSeed(s), u = m.Buffer.concat([i.secretKey.subarray(0, 32), i.publicKey.toBytes()]);
    return {
      privateKey: S.encode(u)
    };
  }
  const n = U(), t = await n.createExportKeyPair();
  return d(e, o(), async ({ user: r, walletSecretId: s }) => {
    const i = await Q(a().projectId, r.userId, {
      address: e.solanaAccount,
      walletSecretId: s,
      exportEncryptionKey: t.publicKeyBase64
    }), u = await n.decryptWithPrivateKey(
      t.privateKey,
      i.encryptedPrivateKey
    ), l = E.fromSeed(new Uint8Array(u)), h = m.Buffer.concat([l.secretKey.subarray(0, 32), l.publicKey.toBytes()]);
    return {
      privateKey: S.encode(h)
    };
  });
}, y = async (e) => {
  if (a().useMock)
    return "redirectUrl" in e ? {
      authUrl: "mock-auth-url",
      flowId: "mock-flow-id"
    } : {
      message: "Mock sign in initiated",
      flowId: "mock-flow-id"
    };
  if (await o().isSignedIn())
    throw new Error("User is already authenticated. Please sign out first.");
  const t = await P(a().projectId, e);
  return "authUrl" in t ? {
    flowId: t.flowId,
    authUrl: t.authUrl
  } : {
    flowId: t.flowId,
    message: "message" in t ? t.message : ""
  };
}, A = async (e, n, t) => {
  if (a().useMock)
    return await o().setAuthState({
      accessToken: "mock-access-token",
      expiresAt: Date.now() + 1e3 * 60 * 60 * 24,
      user: p
    }), {
      message: n,
      user: p,
      isNewUser: !1
    };
  const r = await t(a().projectId, e);
  let s = g(
    r.accessToken,
    r.validUntil,
    r.endUser
  );
  await o().setAuthState(s);
  const i = a();
  i.ethereum?.createOnLogin && (s = await M(
    s,
    r.accessToken,
    r.validUntil,
    i.ethereum.createOnLogin
  )), i.solana?.createOnLogin && (s = await O(
    s,
    r.accessToken,
    r.validUntil
  ));
  const u = o().getUser();
  return {
    message: r.message,
    user: u,
    isNewUser: r.isNewEndUser
  };
}, M = async (e, n, t, r) => {
  let s = e;
  if (!e.user.evmAccountObjects || e.user.evmAccountObjects.length === 0)
    try {
      const i = await o().getWalletSecretId();
      let u = await x(a().projectId, e.user.userId, {
        walletSecretId: i
      }), l = !1;
      const h = a().ethereum;
      if (h?.createOnLogin === "smart" && (l = h.enableSpendPermissions ?? !1), r === "smart") {
        const v = u.evmAccountObjects?.[0]?.address;
        if (!v)
          throw new Error("No EVM account found to use as owner for smart account");
        u = await k(
          a().projectId,
          e.user.userId,
          {
            owner: v,
            enableSpendPermissions: l
          }
        );
      }
      s = g(n, t, u), await o().setAuthState(s);
    } catch (i) {
      throw new Error(`Failed to create EVM account: ${i}`);
    }
  if (r === "smart" && (!s.user.evmSmartAccountObjects || s.user.evmSmartAccountObjects.length === 0))
    try {
      const i = s.user.evmAccountObjects[0]?.address, u = await k(
        a().projectId,
        s.user.userId,
        {
          owner: i,
          enableSpendPermissions: !1
          // Defaulting to false until the feature is ready.
        }
      );
      s = g(n, t, u), await o().setAuthState(s);
    } catch (i) {
      throw new Error(`Failed to create EVM Smart Account: ${i}`);
    }
  return s;
}, O = async (e, n, t) => {
  let r = e;
  if (!e.user.solanaAccountObjects || e.user.solanaAccountObjects.length === 0)
    try {
      const s = await o().getWalletSecretId(), i = await K(
        a().projectId,
        e.user.userId,
        {
          walletSecretId: s
        }
      );
      r = g(n, t, i), await o().setAuthState(r);
    } catch (s) {
      throw new Error(`Failed to create Solana account: ${s}`);
    }
  return r;
};
export {
  je as authenticateWithJWT,
  Qe as exportEvmAccount,
  Xe as exportSolanaAccount,
  We as getAccessToken,
  He as getAccessTokenExpiration,
  Pe as getCurrentUser,
  Ge as getUserOperation,
  _e as initialize,
  xe as isSignedIn,
  Re as onAuthStateChange,
  Be as onOAuthStateChange,
  Je as sendEvmTransaction,
  Le as sendSolanaTransaction,
  qe as sendUserOperation,
  De as signEvmHash,
  ze as signEvmMessage,
  Ne as signEvmTransaction,
  Ve as signEvmTypedData,
  Ue as signInWithEmail,
  Me as signInWithOAuth,
  Ce as signInWithSms,
  Ke as signOut,
  $e as signSolanaMessage,
  Fe as signSolanaTransaction,
  Oe as verifyEmailOTP,
  be as verifyOAuth,
  Te as verifySmsOTP
};
