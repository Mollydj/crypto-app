import { logOutEndUser as u, refreshAccessToken as c, registerTemporaryWalletSecret as f } from "@coinbase/cdp-api-client";
import "jose";
import { SignJWT as S } from "./index.web54.js";
import { toAuthState as d } from "./index.web43.js";
import "viem";
import { getPlatformCrypto as l } from "./index.web4.js";
import { sortKeys as w } from "./index.web48.js";
import { getCoreOAuthManager as m } from "./index.web49.js";
const h = 60 * 1e3, y = {
  maxRetries: 3,
  baseDelayMs: 1e3,
  maxDelayMs: 1e4
};
function g(t, e, s) {
  const r = e * Math.pow(2, t), a = Math.random() * 0.3 * r;
  return Math.min(r + a, s);
}
function T(t) {
  return new Promise((e) => setTimeout(e, t));
}
function p(t) {
  if (t instanceof TypeError && t.message.includes("fetch"))
    return !0;
  if (t && typeof t == "object" && "status" in t) {
    const e = t.status;
    if (e >= 500 && e < 600 || e === 408 || e === 429)
      return !0;
    if (e === 401)
      return !1;
  }
  if (t instanceof Error) {
    const e = t.message.toLowerCase();
    if (e.includes("network") || e.includes("timeout") || e.includes("econnrefused") || e.includes("enotfound") || e.includes("socket"))
      return !0;
  }
  return !1;
}
class M {
  projectId;
  authState = null;
  walletSecret = null;
  authStateChangeCallbacks = [];
  initPromise = null;
  refreshTimeout = null;
  /**
   * Initializes the token manager.
   *
   * @param projectId - The project ID.
   */
  constructor(e) {
    this.projectId = e, this.initPromise = this._doInitialize();
  }
  /**
   * Gets the current user, or null if there is no user signed in.
   *
   * @returns The current user.
   */
  getUser() {
    return this.authState?.user ?? null;
  }
  /**
   * Returns whether the user is signed in - i.e., whether there is an unexpired
   * access token and user. Attempts to refresh the token if it's expired.
   *
   * @returns True if the user is signed in, false otherwise.
   */
  async isSignedIn() {
    if (!this.authState)
      return !1;
    if (this.authState.expiresAt > Date.now() + h)
      return !0;
    try {
      return await this.getToken() !== null;
    } catch {
      return !1;
    }
  }
  /**
   * Signs out the user, clearing all authentication state.
   */
  async signOut() {
    try {
      await u(this.projectId);
    } catch {
    } finally {
      await this.clearAuthState();
    }
  }
  /**
   * Adds a callback to be called when the auth state changes.
   *
   * @param callback - The function to call when the auth state changes.
   */
  addAuthStateChangeCallback(e) {
    this.authStateChangeCallbacks.push(e), e(this.authState?.user ?? null);
  }
  /**
   * Gets the access token, refreshing it if it is expired. Returns null if the user is not
   * signed in.
   *
   * @param options - The options for getting the token.
   * @param options.forceRefresh - Whether to force a refresh of the token.
   * @returns The access token.
   */
  async getToken(e) {
    return (e?.forceRefresh || this.shouldRefreshToken()) && await this.refreshAccessToken(), this.authState?.accessToken ?? null;
  }
  /**
   * Gets the expiration time of the access token, or null if the user is not signed in.
   *
   * @returns The expiration time of the access token.
   */
  async getTokenExpiration() {
    return this.authState?.expiresAt ?? null;
  }
  /**
   * Gets the currently registered wallet secret ID. Rejects if the user is not signed in.
   *
   * @returns The wallet secret ID.
   */
  async getWalletSecretId() {
    if (!await this.isSignedIn())
      throw new Error("Cannot get wallet secret ID if the user is not signed in");
    return this.shouldRefreshWalletSecret() && await this.refreshWalletSecret(), this.walletSecret.walletSecretId;
  }
  /**
   * Gets the X-Wallet-Auth header. Rejects if the user is not signed in.
   *
   * @param options - The options for the request.
   * @param options.requestMethod - The HTTP method of the request.
   * @param options.requestHost - The host of the request.
   * @param options.requestPath - The path of the request.
   * @param options.requestData - The data of the request.
   * @returns The X-Wallet-Auth header.
   */
  async getXWalletAuth(e) {
    if (!await this.isSignedIn())
      throw new Error("Cannot get X-Wallet-Auth header if the user is not signed in");
    this.shouldRefreshWalletSecret() && await this.refreshWalletSecret();
    const s = `${e.requestMethod} ${e.requestHost}${e.requestPath}`, r = Math.floor(Date.now() / 1e3), a = l(), i = {
      uris: [s]
    };
    if (e.requestData && Object.keys(e.requestData).length > 0) {
      const n = w(e.requestData);
      i.reqHash = await a.hash(new TextEncoder().encode(JSON.stringify(n)));
    }
    return await new S(i).setProtectedHeader({ alg: "ES256", typ: "JWT" }).setIssuedAt(r).setNotBefore(r).setJti(a.generateRandomId()).sign(this.walletSecret.keyPair.privateKey);
  }
  /**
   * Gets the authentication state.
   *
   * @returns The authentication state.
   */
  getAuthState() {
    return this.authState;
  }
  /**
   * Sets the authentication state.
   *
   * @param authState - The authentication state.
   */
  async setAuthState(e) {
    this.authState = e, this.authStateChangeCallbacks.forEach((s) => s(this.authState?.user ?? null)), this.scheduleTokenRefresh();
  }
  /**
   * Clears the authentication state.
   */
  async clearAuthState() {
    this.authState = null, this.walletSecret = null, this.cancelTokenRefresh(), this.authStateChangeCallbacks.forEach((e) => e(null));
  }
  /**
   * Ensures the AuthManager is initialized before proceeding.
   * If initialization is already in progress, waits for it to complete.
   */
  async ensureInitialized() {
    if (this.initPromise) {
      await this.initPromise;
      return;
    }
    throw new Error("AuthManager not initialized");
  }
  /**
   * Internal async initialization logic.
   */
  async _doInitialize() {
    try {
      await this.refreshAccessToken(), await m().handleOAuthCode();
    } catch (e) {
      console.warn("Failed to refresh access token during initialization:", e);
    }
  }
  /**
   * Returns whether the token should be refreshed.
   *
   * @returns True if the token should be refreshed, false otherwise.
   */
  shouldRefreshToken() {
    return !(this.authState && this.authState.expiresAt > Date.now() + h);
  }
  /**
   * Refreshes the access token and transitions the auth state accordingly.
   * If a refresh is already in progress, it will wait for that refresh to complete.
   * Retries with exponential backoff on transient failures only. Unauthorized error
   * short-circuit immediately since retrying won't help.
   *
   * @returns The new access token.
   */
  async refreshAccessToken() {
    const { maxRetries: e, baseDelayMs: s, maxDelayMs: r } = y;
    for (let a = 0; a <= e; a++)
      try {
        const i = await c(this.projectId, {
          grantType: "refresh_token"
        }), n = d(
          i.accessToken,
          i.validUntil,
          i.endUser
        );
        await this.setAuthState(n);
        return;
      } catch (i) {
        if (!p(i)) {
          await this.signOut();
          return;
        }
        if (a === e)
          return;
        const o = g(a, s, r);
        await T(o);
      }
  }
  /**
   * Schedules a token refresh to occur exactly when shouldRefreshToken() would return true.
   * Uses the same REFRESH_CREDENTIALS_BUFFER_MS timing as the rest of the auth system.
   */
  scheduleTokenRefresh() {
    if (this.cancelTokenRefresh(), !this.authState)
      return;
    const s = this.authState.expiresAt - h - Date.now();
    s <= 0 || (this.refreshTimeout = setTimeout(async () => {
      await this.refreshAccessToken(), this.scheduleTokenRefresh();
    }, s));
  }
  /**
   * Cancels any scheduled token refresh.
   */
  cancelTokenRefresh() {
    this.refreshTimeout && (clearTimeout(this.refreshTimeout), this.refreshTimeout = null);
  }
  /**
   * Returns whether the wallet secret should be refreshed.
   *
   * @returns True if the wallet secret should be refreshed, false otherwise.
   */
  shouldRefreshWalletSecret() {
    return !(this.walletSecret && this.walletSecret.expiresAt > Date.now() + h);
  }
  /**
   * Refreshes the wallet secret. Assumes the user is signed in.
   *
   * @returns The wallet secret.
   */
  async refreshWalletSecret() {
    const e = l(), s = this.walletSecret?.walletSecretId ?? e.generateRandomId(), r = this.walletSecret?.keyPair ?? await e.createKeyPair(), a = this.authState.expiresAt, i = new Date(a).toISOString();
    this.walletSecret = { walletSecretId: s, keyPair: r, expiresAt: a };
    try {
      await f(this.projectId, this.authState.user.userId, {
        walletSecretId: s,
        publicKey: r.publicKeyBase64,
        validUntil: i
      });
    } catch (n) {
      throw this.walletSecret = null, n;
    }
  }
}
export {
  M as AuthManager
};
