import { hashTypedData as i, serializeErc6492Signature as u, encodeFunctionData as m, pad as g, getTypesForEIP712Domain as A, hashMessage as d } from "viem";
import { getCurrentUserSync as h } from "./index.web13.js";
import { signEvmHash as o, signEvmTypedData as l, signEvmTransaction as f, signEvmMessage as y } from "./index.web9.js";
import "@coinbase/cdp-api-client";
import { COINBASE_SMART_WALLET_FACTORY_ADDRESS as p, COINBASE_SMART_WALLET_FACTORY_ABI as v } from "./index.web55.js";
import { signAndWrapTypedDataForSmartAccount as E } from "./index.web56.js";
import { toAccount as T } from "./index.web57.js";
function _(n) {
  const r = h();
  if (!r || !r.evmAccountObjects?.length && !r.evmSmartAccountObjects?.length)
    throw new Error(
      "No accounts found - user must be authenticated and have at least one EVM account or smart account"
    );
  const c = r.evmAccountObjects?.some((e) => e.address === n) ?? !1, s = r.evmSmartAccountObjects?.some((e) => e.address === n) ?? !1;
  if (!c && !s)
    throw new Error(`Cannot sign for address ${n} - not authorized for this account`);
  return T({
    address: n,
    /**
     * Signs a message using CDP's message signing functionality.
     * Supports string messages, hex strings, and byte arrays.
     *
     * @param root0 - The parameters object
     * @param root0.message - The message to sign, can be a string, hex string, or byte array
     * @returns The signature as a hex string
     */
    async signMessage({ message: e }) {
      let t;
      if (typeof e == "string")
        t = (await y({
          evmAccount: n,
          message: e
        })).signature;
      else if ("raw" in e) {
        const a = d(e);
        t = (await o({
          evmAccount: n,
          hash: a
        })).signature;
      } else
        throw new Error("Unsupported message format");
      return t;
    },
    /**
     * Signs a transaction using CDP's transaction signing functionality.
     * Converts Viem's transaction format to CDP's AllowedEvmTransactionType.
     *
     * @param transaction - The transaction to sign in Viem's format
     * @returns The signature as a hex string
     */
    async signTransaction(e) {
      const t = {
        to: e.to,
        value: e.value,
        data: e.data,
        nonce: e.nonce,
        gas: e.gas,
        chainId: e.chainId ?? 1
      };
      return e.gasPrice !== void 0 ? (t.maxFeePerGas = e.gasPrice, t.maxPriorityFeePerGas = e.gasPrice) : (t.maxFeePerGas = e.maxFeePerGas, t.maxPriorityFeePerGas = e.maxPriorityFeePerGas), (await f({
        evmAccount: n,
        transaction: t
      })).signedTransaction;
    },
    /**
     * Signs EIP-712 typed data using CDP's typed data signing functionality.
     * Handles domain separation and type encoding according to the EIP-712 specification.
     * For smart accounts, implements replay-safe hash and signature wrapping.
     *
     * @param params - The typed data parameters following the EIP-712 specification
     * @returns The signature as a hex string
     */
    async signTypedData(e) {
      if (s) {
        const t = await E({
          smartAccount: n,
          ownerAddress: r.evmAccountObjects?.[0]?.address,
          hash: i(e),
          chainId: Number(e.domain.chainId)
        });
        return u({
          address: p,
          data: m({
            abi: v,
            functionName: "createAccount",
            args: [[g(r.evmAccountObjects?.[0]?.address)], 0n]
          }),
          signature: t.signature
        });
      } else {
        const t = {
          domain: e.domain,
          types: {
            EIP712Domain: A({
              domain: e.domain
            }),
            ...e.types
          },
          primaryType: e.primaryType,
          message: e.message
        };
        return (await l({
          evmAccount: n,
          typedData: t
        })).signature;
      }
    },
    /**
     * Signs a raw message hash using CDP's message signing functionality.
     *
     * @param message - The message hash to sign
     * @returns The signature as a hex string
     */
    async sign(e) {
      return (await o({
        evmAccount: n,
        hash: e.hash
      })).signature;
    }
  });
}
export {
  _ as toViemAccount
};
