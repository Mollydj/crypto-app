import { addressResolverAbi as u, universalResolverResolveAbi as h } from "./index97.js";
import { decodeFunctionResult as A } from "./index155.js";
import { encodeFunctionData as R } from "./index162.js";
import { getChainContractAddress as b } from "./index198.js";
import { trim as w } from "./index147.js";
import { toHex as C } from "./index134.js";
import { isNullUniversalResolverError as y } from "./index243.js";
import { localBatchGatewayUrl as x } from "./index188.js";
import { namehash as i } from "./index137.js";
import { packetToBytes as N } from "./index244.js";
import { getAction as B } from "./index237.js";
import { readContract as T } from "./index80.js";
async function J(a, o) {
  const { blockNumber: l, blockTag: m, coinType: t, name: e, gatewayUrls: f, strict: v } = o, { chain: n } = a, p = (() => {
    if (o.universalResolverAddress)
      return o.universalResolverAddress;
    if (!n)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return b({
      blockNumber: l,
      chain: n,
      contract: "ensUniversalResolver"
    });
  })(), c = n?.ensTlds;
  if (c && !c.some((r) => e.endsWith(r)))
    return null;
  try {
    const r = R({
      abi: u,
      functionName: "addr",
      ...t != null ? { args: [i(e), BigInt(t)] } : { args: [i(e)] }
    }), g = {
      address: p,
      abi: h,
      functionName: "resolve",
      args: [
        C(N(e)),
        r,
        f ?? [x]
      ],
      blockNumber: l,
      blockTag: m
    }, d = await B(a, T, "readContract")(g);
    if (d[0] === "0x")
      return null;
    const s = A({
      abi: u,
      args: t != null ? [i(e), BigInt(t)] : void 0,
      functionName: "addr",
      data: d[0]
    });
    return s === "0x" || w(s) === "0x00" ? null : s;
  } catch (r) {
    if (v)
      throw r;
    if (y(r, "resolve"))
      return null;
    throw r;
  }
}
export {
  J as getEnsAddress
};
