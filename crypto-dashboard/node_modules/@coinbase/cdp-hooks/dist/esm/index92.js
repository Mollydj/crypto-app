import { getAction as c } from "./index237.js";
import { observe as p } from "./index239.js";
import { poll as b } from "./index240.js";
import { stringify as m } from "./index128.js";
import { createPendingTransactionFilter as d } from "./index54.js";
import { getFilterChanges as h } from "./index69.js";
import { uninstallFilter as P } from "./index84.js";
function D(r, { batch: u = !0, onError: i, onTransactions: l, poll: f, pollingInterval: g = r.pollingInterval }) {
  return (typeof f < "u" ? f : r.transport.type !== "webSocket" && r.transport.type !== "ipc") ? (() => {
    const a = m([
      "watchPendingTransactions",
      r.uid,
      u,
      g
    ]);
    return p(a, { onTransactions: l, onError: i }, (t) => {
      let n;
      const s = b(async () => {
        try {
          if (!n)
            try {
              n = await c(r, d, "createPendingTransactionFilter")({});
              return;
            } catch (o) {
              throw s(), o;
            }
          const e = await c(r, h, "getFilterChanges")({ filter: n });
          if (e.length === 0)
            return;
          if (u)
            t.onTransactions(e);
          else
            for (const o of e)
              t.onTransactions([o]);
        } catch (e) {
          t.onError?.(e);
        }
      }, {
        emitOnBegin: !0,
        interval: g
      });
      return async () => {
        n && await c(r, P, "uninstallFilter")({ filter: n }), s();
      };
    });
  })() : (() => {
    let a = !0, t = () => a = !1;
    return (async () => {
      try {
        const { unsubscribe: n } = await r.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(s) {
            if (!a)
              return;
            const e = s.result;
            l([e]);
          },
          onError(s) {
            i?.(s);
          }
        });
        t = n, a || t();
      } catch (n) {
        i?.(n);
      }
    })(), () => t();
  })();
}
export {
  D as watchPendingTransactions
};
