import { isHex as i } from "./index170.js";
import { size as b } from "./index106.js";
import { hexToBigInt as n, hexToNumber as d } from "./index167.js";
import { toHex as c } from "./index134.js";
async function R({ hash: r, signature: e }) {
  const u = i(r) ? r : c(r), { secp256k1: t } = await import("./index177.js");
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: p, s: v, v: y, yParity: l } = e, x = Number(l ?? y), a = s(x);
      return new t.Signature(n(p), n(v)).addRecoveryBit(a);
    }
    const o = i(e) ? e : c(e);
    if (b(o) !== 65)
      throw new Error("invalid signature length");
    const f = d(`0x${o.slice(130)}`), m = s(f);
    return t.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(m);
  })().recoverPublicKey(u.substring(2)).toHex(!1)}`;
}
function s(r) {
  if (r === 0 || r === 1)
    return r;
  if (r === 27)
    return 0;
  if (r === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
export {
  R as recoverPublicKey
};
