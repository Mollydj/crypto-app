import { numberToBytesLE as y, numberToBytesBE as I, bitMask as Z, bytesToNumberLE as S, bytesToNumberBE as _, _validateObject as j } from "./index285.js";
import { anumber as z } from "./index270.js";
const g = BigInt(0), d = BigInt(1), q = /* @__PURE__ */ BigInt(2), V = /* @__PURE__ */ BigInt(3), x = /* @__PURE__ */ BigInt(4), T = /* @__PURE__ */ BigInt(5), L = /* @__PURE__ */ BigInt(8);
function h(t, n) {
  const o = t % n;
  return o >= g ? o : n + o;
}
function O(t, n, o) {
  let r = t;
  for (; n-- > g; )
    r *= r, r %= o;
  return r;
}
function B(t, n) {
  if (t === g)
    throw new Error("invert: expected non-zero number");
  if (n <= g)
    throw new Error("invert: expected positive modulus, got " + n);
  let o = h(t, n), r = n, s = g, f = d;
  for (; o !== g; ) {
    const u = r / o, i = r % o, w = s - f * u;
    r = o, o = i, s = f, f = w;
  }
  if (r !== d)
    throw new Error("invert: does not exist");
  return h(s, n);
}
function M(t, n) {
  const o = (t.ORDER + d) / x, r = t.pow(n, o);
  if (!t.eql(t.sqr(r), n))
    throw new Error("Cannot find square root");
  return r;
}
function H(t, n) {
  const o = (t.ORDER - T) / L, r = t.mul(n, q), s = t.pow(r, o), f = t.mul(n, s), c = t.mul(t.mul(f, q), s), u = t.mul(f, t.sub(c, t.ONE));
  if (!t.eql(t.sqr(u), n))
    throw new Error("Cannot find square root");
  return u;
}
function K(t) {
  if (t < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let n = t - d, o = 0;
  for (; n % q === g; )
    n /= q, o++;
  let r = q;
  const s = U(t);
  for (; N(s, r) === 1; )
    if (r++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (o === 1)
    return M;
  let f = s.pow(r, n);
  const c = (n + d) / q;
  return function(i, w) {
    if (i.is0(w))
      return w;
    if (N(i, w) !== 1)
      throw new Error("Cannot find square root");
    let e = o, l = i.mul(i.ONE, f), a = i.pow(w, n), b = i.pow(w, c);
    for (; !i.eql(a, i.ONE); ) {
      if (i.is0(a))
        return i.ZERO;
      let m = 1, E = i.sqr(a);
      for (; !i.eql(E, i.ONE); )
        if (m++, E = i.sqr(E), m === e)
          throw new Error("Cannot find square root");
      const C = d << BigInt(e - m - 1), v = i.pow(l, C);
      e = m, l = i.sqr(v), a = i.mul(a, l), b = i.mul(b, v);
    }
    return b;
  };
}
function Q(t) {
  return t % x === V ? M : t % L === T ? H : K(t);
}
const Y = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function P(t) {
  const n = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  }, o = Y.reduce((r, s) => (r[s] = "function", r), n);
  return j(t, o), t;
}
function k(t, n, o) {
  if (o < g)
    throw new Error("invalid exponent, negatives unsupported");
  if (o === g)
    return t.ONE;
  if (o === d)
    return n;
  let r = t.ONE, s = n;
  for (; o > g; )
    o & d && (r = t.mul(r, s)), s = t.sqr(s), o >>= d;
  return r;
}
function G(t, n, o = !1) {
  const r = new Array(n.length).fill(o ? t.ZERO : void 0), s = n.reduce((c, u, i) => t.is0(u) ? c : (r[i] = c, t.mul(c, u)), t.ONE), f = t.inv(s);
  return n.reduceRight((c, u, i) => t.is0(u) ? c : (r[i] = t.mul(c, r[i]), t.mul(c, u)), f), r;
}
function N(t, n) {
  const o = (t.ORDER - d) / q, r = t.pow(n, o), s = t.eql(r, t.ONE), f = t.eql(r, t.ZERO), c = t.eql(r, t.neg(t.ONE));
  if (!s && !f && !c)
    throw new Error("invalid Legendre symbol result");
  return s ? 1 : f ? 0 : -1;
}
function J(t, n) {
  n !== void 0 && z(n);
  const o = n !== void 0 ? n : t.toString(2).length, r = Math.ceil(o / 8);
  return { nBitLength: o, nByteLength: r };
}
function U(t, n, o = !1, r = {}) {
  if (t <= g)
    throw new Error("invalid field: expected ORDER > 0, got " + t);
  let s, f;
  if (typeof n == "object" && n != null) {
    if (r.sqrt || o)
      throw new Error("cannot specify opts in two arguments");
    const e = n;
    e.BITS && (s = e.BITS), e.sqrt && (f = e.sqrt), typeof e.isLE == "boolean" && (o = e.isLE);
  } else
    typeof n == "number" && (s = n), r.sqrt && (f = r.sqrt);
  const { nBitLength: c, nByteLength: u } = J(t, s);
  if (u > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let i;
  const w = Object.freeze({
    ORDER: t,
    isLE: o,
    BITS: c,
    BYTES: u,
    MASK: Z(c),
    ZERO: g,
    ONE: d,
    create: (e) => h(e, t),
    isValid: (e) => {
      if (typeof e != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof e);
      return g <= e && e < t;
    },
    is0: (e) => e === g,
    // is valid and invertible
    isValidNot0: (e) => !w.is0(e) && w.isValid(e),
    isOdd: (e) => (e & d) === d,
    neg: (e) => h(-e, t),
    eql: (e, l) => e === l,
    sqr: (e) => h(e * e, t),
    add: (e, l) => h(e + l, t),
    sub: (e, l) => h(e - l, t),
    mul: (e, l) => h(e * l, t),
    pow: (e, l) => k(w, e, l),
    div: (e, l) => h(e * B(l, t), t),
    // Same as above, but doesn't normalize
    sqrN: (e) => e * e,
    addN: (e, l) => e + l,
    subN: (e, l) => e - l,
    mulN: (e, l) => e * l,
    inv: (e) => B(e, t),
    sqrt: f || ((e) => (i || (i = Q(t)), i(w, e))),
    toBytes: (e) => o ? y(e, u) : I(e, u),
    fromBytes: (e) => {
      if (e.length !== u)
        throw new Error("Field.fromBytes: expected " + u + " bytes, got " + e.length);
      return o ? S(e) : _(e);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (e) => G(w, e),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (e, l, a) => a ? l : e
  });
  return Object.freeze(w);
}
function A(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const n = t.toString(2).length;
  return Math.ceil(n / 8);
}
function W(t) {
  const n = A(t);
  return n + Math.ceil(n / 2);
}
function D(t, n, o = !1) {
  const r = t.length, s = A(n), f = W(n);
  if (r < 16 || r < f || r > 1024)
    throw new Error("expected " + f + "-1024 bytes of input, got " + r);
  const c = o ? S(t) : _(t), u = h(c, n - d) + d;
  return o ? y(u, s) : I(u, s);
}
export {
  U as Field,
  G as FpInvertBatch,
  N as FpLegendre,
  k as FpPow,
  Q as FpSqrt,
  A as getFieldBytesLength,
  W as getMinHashLength,
  B as invert,
  D as mapHashToField,
  h as mod,
  J as nLength,
  O as pow2,
  K as tonelliShanks,
  P as validateField
};
