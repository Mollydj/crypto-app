import { encodeEventTopics as S } from "./index161.js";
import { observe as B } from "./index239.js";
import { poll as C } from "./index240.js";
import { stringify as T } from "./index128.js";
import { DecodeLogDataMismatch as z, DecodeLogTopicsMismatch as A } from "./index104.js";
import { InvalidInputRpcError as O } from "./index121.js";
import { decodeEventLog as P } from "./index151.js";
import { formatLog as I } from "./index142.js";
import { getAction as u } from "./index237.js";
import { createEventFilter as R } from "./index53.js";
import { getBlockNumber as U } from "./index62.js";
import { getFilterChanges as j } from "./index69.js";
import { getLogs as q } from "./index72.js";
import { uninstallFilter as x } from "./index84.js";
function nt(r, { address: m, args: l, batch: h = !0, event: s, events: d, fromBlock: c, onError: y, onLogs: v, poll: E, pollingInterval: k = r.pollingInterval, strict: N }) {
  const D = typeof E < "u" ? E : typeof c == "bigint" ? !0 : !(r.transport.type === "webSocket" || r.transport.type === "ipc" || r.transport.type === "fallback" && (r.transport.transports[0].config.type === "webSocket" || r.transport.transports[0].config.type === "ipc")), F = N ?? !1;
  return D ? (() => {
    const p = T([
      "watchEvent",
      m,
      l,
      h,
      r.uid,
      s,
      k,
      c
    ]);
    return B(p, { onLogs: v, onError: y }, (a) => {
      let n;
      c !== void 0 && (n = c - 1n);
      let o, i = !1;
      const w = C(async () => {
        if (!i) {
          try {
            o = await u(r, R, "createEventFilter")({
              address: m,
              args: l,
              event: s,
              events: d,
              strict: F,
              fromBlock: c
            });
          } catch {
          }
          i = !0;
          return;
        }
        try {
          let t;
          if (o)
            t = await u(r, j, "getFilterChanges")({ filter: o });
          else {
            const e = await u(r, U, "getBlockNumber")({});
            n && n !== e ? t = await u(r, q, "getLogs")({
              address: m,
              args: l,
              event: s,
              events: d,
              fromBlock: n + 1n,
              toBlock: e
            }) : t = [], n = e;
          }
          if (t.length === 0)
            return;
          if (h)
            a.onLogs(t);
          else
            for (const e of t)
              a.onLogs([e]);
        } catch (t) {
          o && t instanceof O && (i = !1), a.onError?.(t);
        }
      }, {
        emitOnBegin: !0,
        interval: k
      });
      return async () => {
        o && await u(r, x, "uninstallFilter")({ filter: o }), w();
      };
    });
  })() : (() => {
    let p = !0, a = () => p = !1;
    return (async () => {
      try {
        const n = (() => {
          if (r.transport.type === "fallback") {
            const t = r.transport.transports.find((e) => e.config.type === "webSocket" || e.config.type === "ipc");
            return t ? t.value : r.transport;
          }
          return r.transport;
        })(), o = d ?? (s ? [s] : void 0);
        let i = [];
        o && (i = [o.flatMap((e) => S({
          abi: [e],
          eventName: e.name,
          args: l
        }))], s && (i = i[0]));
        const { unsubscribe: w } = await n.subscribe({
          params: ["logs", { address: m, topics: i }],
          onData(t) {
            if (!p)
              return;
            const e = t.result;
            try {
              const { eventName: f, args: b } = P({
                abi: o ?? [],
                data: e.data,
                topics: e.topics,
                strict: F
              }), g = I(e, { args: b, eventName: f });
              v([g]);
            } catch (f) {
              let b, g;
              if (f instanceof z || f instanceof A) {
                if (N)
                  return;
                b = f.abiItem.name, g = f.abiItem.inputs?.some((L) => !("name" in L && L.name));
              }
              const M = I(e, {
                args: g ? [] : {},
                eventName: b
              });
              v([M]);
            }
          },
          onError(t) {
            y?.(t);
          }
        });
        a = w, p || a();
      } catch (n) {
        y?.(n);
      }
    })(), () => a();
  })();
}
export {
  nt as watchEvent
};
