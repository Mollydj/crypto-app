import { readContract as w } from "./index80.js";
import { EnsAvatarUriResolutionError as d, EnsAvatarInvalidNftUriError as p, EnsAvatarUnsupportedNamespaceError as I, EnsAvatarInvalidMetadataError as y } from "./index124.js";
const v = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, A = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, b = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, E = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function k(e) {
  try {
    const t = await fetch(e, { method: "HEAD" });
    return t.status === 200 ? t.headers.get("content-type")?.startsWith("image/") : !1;
  } catch (t) {
    return typeof t == "object" && typeof t.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((n) => {
      const a = new Image();
      a.onload = () => {
        n(!0);
      }, a.onerror = () => {
        n(!1);
      }, a.src = e;
    });
  }
}
function l(e, t) {
  return e ? e.endsWith("/") ? e.slice(0, -1) : e : t;
}
function C({ uri: e, gatewayUrls: t }) {
  const n = b.test(e);
  if (n)
    return { uri: e, isOnChain: !0, isEncoded: n };
  const a = l(t?.ipfs, "https://ipfs.io"), r = l(t?.arweave, "https://arweave.net"), f = e.match(v), { protocol: i, subpath: c, target: s, subtarget: h = "" } = f?.groups || {}, u = i === "ipns:/" || c === "ipns/", m = i === "ipfs:/" || c === "ipfs/" || A.test(e);
  if (e.startsWith("http") && !u && !m) {
    let g = e;
    return t?.arweave && (g = e.replace(/https:\/\/arweave.net/g, t?.arweave)), { uri: g, isOnChain: !1, isEncoded: !1 };
  }
  if ((u || m) && s)
    return {
      uri: `${a}/${u ? "ipns" : "ipfs"}/${s}${h}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (i === "ar:/" && s)
    return {
      uri: `${r}/${s}${h || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let o = e.replace(E, "");
  if (o.startsWith("<svg") && (o = `data:image/svg+xml;base64,${btoa(o)}`), o.startsWith("data:") || o.startsWith("{"))
    return {
      uri: o,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new d({ uri: e });
}
function U(e) {
  if (typeof e != "object" || !("image" in e) && !("image_url" in e) && !("image_data" in e))
    throw new y({ data: e });
  return e.image || e.image_url || e.image_data;
}
async function $({ gatewayUrls: e, uri: t }) {
  try {
    const n = await fetch(t).then((r) => r.json());
    return await R({
      gatewayUrls: e,
      uri: U(n)
    });
  } catch {
    throw new d({ uri: t });
  }
}
async function R({ gatewayUrls: e, uri: t }) {
  const { uri: n, isOnChain: a } = C({ uri: t, gatewayUrls: e });
  if (a || await k(n))
    return n;
  throw new d({ uri: t });
}
function D(e) {
  let t = e;
  t.startsWith("did:nft:") && (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [n, a, r] = t.split("/"), [f, i] = n.split(":"), [c, s] = a.split(":");
  if (!f || f.toLowerCase() !== "eip155")
    throw new p({ reason: "Only EIP-155 supported" });
  if (!i)
    throw new p({ reason: "Chain ID not found" });
  if (!s)
    throw new p({
      reason: "Contract address not found"
    });
  if (!r)
    throw new p({ reason: "Token ID not found" });
  if (!c)
    throw new p({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(i),
    namespace: c.toLowerCase(),
    contractAddress: s,
    tokenID: r
  };
}
async function O(e, { nft: t }) {
  if (t.namespace === "erc721")
    return w(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(t.tokenID)]
    });
  if (t.namespace === "erc1155")
    return w(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(t.tokenID)]
    });
  throw new I({ namespace: t.namespace });
}
export {
  l as getGateway,
  U as getJsonImage,
  $ as getMetadataAvatarUri,
  O as getNftTokenUri,
  k as isImageUri,
  R as parseAvatarUri,
  D as parseNftUri,
  C as resolveAvatarUri
};
