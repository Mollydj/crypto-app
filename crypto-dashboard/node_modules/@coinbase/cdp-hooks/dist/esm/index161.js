import { AbiEventNotFoundError as p } from "./index104.js";
import { FilterTypeNotSupportedError as A } from "./index127.js";
import { toBytes as b } from "./index133.js";
import { keccak256 as g } from "./index135.js";
import { toEventSelector as v } from "./index152.js";
import { encodeAbiParameters as h } from "./index149.js";
import { formatAbiItem as w } from "./index105.js";
import { getAbiItem as E } from "./index114.js";
const d = "/docs/contract/encodeEventTopics";
function j(t) {
  const { abi: r, eventName: f, args: i } = t;
  let c = r[0];
  if (f) {
    const s = E({ abi: r, name: f });
    if (!s)
      throw new p(f, { docsPath: d });
    c = s;
  }
  if (c.type !== "event")
    throw new p(void 0, { docsPath: d });
  const l = w(c), y = v(l);
  let m = [];
  if (i && "inputs" in c) {
    const s = c.inputs?.filter((n) => "indexed" in n && n.indexed), e = Array.isArray(i) ? i : Object.values(i).length > 0 ? s?.map((n) => i[n.name]) ?? [] : [];
    e.length > 0 && (m = s?.map((n, o) => Array.isArray(e[o]) ? e[o].map((x, a) => u({ param: n, value: e[o][a] })) : typeof e[o] < "u" && e[o] !== null ? u({ param: n, value: e[o] }) : null) ?? []);
  }
  return [y, ...m];
}
function u({ param: t, value: r }) {
  if (t.type === "string" || t.type === "bytes")
    return g(b(r));
  if (t.type === "tuple" || t.type.match(/^(.*)\[(\d+)?\]$/))
    throw new A(t.type);
  return h([t], [r]);
}
export {
  j as encodeEventTopics
};
