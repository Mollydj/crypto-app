import { crypto as u } from "./index283.js";
function w(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function l(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function c(t, ...e) {
  if (!w(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function U(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  l(t.outputLen), l(t.blockLen);
}
function B(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function H(t, e) {
  c(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error("digestInto() expects output buffer of length at least " + n);
}
function L(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function V(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function _(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function S(t, e) {
  return t << 32 - e | t >>> e;
}
const d = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function h(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function x(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = h(t[e]);
  return t;
}
const T = d ? (t) => t : x, p = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", A = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function k(t) {
  if (c(t), p)
    return t.toHex();
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += A[t[n]];
  return e;
}
const f = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function y(t) {
  if (t >= f._0 && t <= f._9)
    return t - f._0;
  if (t >= f.A && t <= f.F)
    return t - (f.A - 10);
  if (t >= f.a && t <= f.f)
    return t - (f.a - 10);
}
function I(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (p)
    return Uint8Array.fromHex(t);
  const e = t.length, n = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let o = 0, i = 0; o < n; o++, i += 2) {
    const s = y(t.charCodeAt(i)), a = y(t.charCodeAt(i + 1));
    if (s === void 0 || a === void 0) {
      const g = t[i] + t[i + 1];
      throw new Error('hex string expected, got non-hex character "' + g + '" at index ' + i);
    }
    r[o] = s * 16 + a;
  }
  return r;
}
function m(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function b(t) {
  return typeof t == "string" && (t = m(t)), c(t), t;
}
function R(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const o = t[r];
    c(o), e += o.length;
  }
  const n = new Uint8Array(e);
  for (let r = 0, o = 0; r < t.length; r++) {
    const i = t[r];
    n.set(i, o), o += i.length;
  }
  return n;
}
class F {
}
function O(t) {
  const e = (r) => t().update(b(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
function v(t = 32) {
  if (u && typeof u.getRandomValues == "function")
    return u.getRandomValues(new Uint8Array(t));
  if (u && typeof u.randomBytes == "function")
    return Uint8Array.from(u.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
export {
  F as Hash,
  c as abytes,
  B as aexists,
  U as ahash,
  l as anumber,
  H as aoutput,
  h as byteSwap,
  x as byteSwap32,
  k as bytesToHex,
  V as clean,
  R as concatBytes,
  O as createHasher,
  _ as createView,
  I as hexToBytes,
  w as isBytes,
  d as isLE,
  v as randomBytes,
  S as rotr,
  T as swap32IfBE,
  b as toBytes,
  L as u32,
  m as utf8ToBytes
};
