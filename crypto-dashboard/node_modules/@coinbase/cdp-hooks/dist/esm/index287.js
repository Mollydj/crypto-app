import { bitLen as B, bitMask as z } from "./index285.js";
import { validateField as Z, Field as O, FpInvertBatch as R } from "./index265.js";
const g = BigInt(0), h = BigInt(1);
function b(t, r) {
  const e = r.negate();
  return t ? e : r;
}
function L(t, r, e) {
  const n = (s) => s.pz, i = R(t.Fp, e.map(n));
  return e.map((s, f) => s.toAffine(i[f])).map(t.fromAffine);
}
function I(t, r) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > r)
    throw new Error("invalid window size, expected [1.." + r + "], got W=" + t);
}
function E(t, r) {
  I(t, r);
  const e = Math.ceil(r / t) + 1, n = 2 ** (t - 1), i = 2 ** t, o = z(t), s = BigInt(t);
  return { windows: e, windowSize: n, mask: o, maxNumber: i, shiftBy: s };
}
function v(t, r, e) {
  const { windowSize: n, mask: i, maxNumber: o, shiftBy: s } = e;
  let f = Number(t & i), a = t >> s;
  f > n && (f -= o, a += h);
  const d = r * n, c = d + Math.abs(f) - 1, p = f === 0, l = f < 0, u = r % 2 !== 0;
  return { nextN: a, offset: c, isZero: p, isNeg: l, isNegF: u, offsetF: d };
}
function j(t, r) {
  if (!Array.isArray(t))
    throw new Error("array expected");
  t.forEach((e, n) => {
    if (!(e instanceof r))
      throw new Error("invalid point at index " + n);
  });
}
function _(t, r) {
  if (!Array.isArray(t))
    throw new Error("array of scalars expected");
  t.forEach((e, n) => {
    if (!r.isValid(e))
      throw new Error("invalid scalar at index " + n);
  });
}
const N = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap();
function A(t) {
  return M.get(t) || 1;
}
function S(t) {
  if (t !== g)
    throw new Error("invalid wNAF");
}
function U(t, r) {
  return {
    constTimeNegate: b,
    hasPrecomputes(e) {
      return A(e) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(e, n, i = t.ZERO) {
      let o = e;
      for (; n > g; )
        n & h && (i = i.add(o)), o = o.double(), n >>= h;
      return i;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(ğ‘Šâˆ’1) * (Math.ceil(ğ‘› / ğ‘Š) + 1), where:
     * - ğ‘Š is the window size
     * - ğ‘› is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(e, n) {
      const { windows: i, windowSize: o } = E(n, r), s = [];
      let f = e, a = f;
      for (let d = 0; d < i; d++) {
        a = f, s.push(a);
        for (let c = 1; c < o; c++)
          a = a.add(f), s.push(a);
        f = a.double();
      }
      return s;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(e, n, i) {
      let o = t.ZERO, s = t.BASE;
      const f = E(e, r);
      for (let a = 0; a < f.windows; a++) {
        const { nextN: d, offset: c, isZero: p, isNeg: l, isNegF: u, offsetF: m } = v(i, a, f);
        i = d, p ? s = s.add(b(u, n[m])) : o = o.add(b(l, n[c]));
      }
      return S(i), { p: o, f: s };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(e, n, i, o = t.ZERO) {
      const s = E(e, r);
      for (let f = 0; f < s.windows && i !== g; f++) {
        const { nextN: a, offset: d, isZero: c, isNeg: p } = v(i, f, s);
        if (i = a, !c) {
          const l = n[d];
          o = o.add(p ? l.negate() : l);
        }
      }
      return S(i), o;
    },
    getPrecomputes(e, n, i) {
      let o = N.get(n);
      return o || (o = this.precomputeWindow(n, e), e !== 1 && (typeof i == "function" && (o = i(o)), N.set(n, o))), o;
    },
    wNAFCached(e, n, i) {
      const o = A(e);
      return this.wNAF(o, this.getPrecomputes(o, e, i), n);
    },
    wNAFCachedUnsafe(e, n, i, o) {
      const s = A(e);
      return s === 1 ? this.unsafeLadder(e, n, o) : this.wNAFUnsafe(s, this.getPrecomputes(s, e, i), n, o);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(e, n) {
      I(n, r), M.set(e, n), N.delete(e);
    }
  };
}
function $(t, r, e, n) {
  let i = r, o = t.ZERO, s = t.ZERO;
  for (; e > g || n > g; )
    e & h && (o = o.add(i)), n & h && (s = s.add(i)), i = i.double(), e >>= h, n >>= h;
  return { p1: o, p2: s };
}
function D(t, r, e, n) {
  j(e, t), _(n, r);
  const i = e.length, o = n.length;
  if (i !== o)
    throw new Error("arrays of points and scalars must have equal length");
  const s = t.ZERO, f = B(BigInt(i));
  let a = 1;
  f > 12 ? a = f - 3 : f > 4 ? a = f - 2 : f > 0 && (a = 2);
  const d = z(a), c = new Array(Number(d) + 1).fill(s), p = Math.floor((r.BITS - 1) / a) * a;
  let l = s;
  for (let u = p; u >= 0; u -= a) {
    c.fill(s);
    for (let w = 0; w < o; w++) {
      const F = n[w], y = Number(F >> BigInt(u) & d);
      c[y] = c[y].add(e[w]);
    }
    let m = s;
    for (let w = c.length - 1, F = s; w > 0; w--)
      F = F.add(c[w]), m = m.add(F);
    if (l = l.add(m), u !== 0)
      for (let w = 0; w < a; w++)
        l = l.double();
  }
  return l;
}
function x(t, r) {
  if (r) {
    if (r.ORDER !== t)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Z(r), r;
  } else
    return O(t);
}
function G(t, r, e = {}) {
  if (!r || typeof r != "object")
    throw new Error(`expected valid ${t} CURVE object`);
  for (const f of ["p", "n", "h"]) {
    const a = r[f];
    if (!(typeof a == "bigint" && a > g))
      throw new Error(`CURVE.${f} must be positive bigint`);
  }
  const n = x(r.p, e.Fp), i = x(r.n, e.Fn), s = ["Gx", "Gy", "a", "b"];
  for (const f of s)
    if (!n.isValid(r[f]))
      throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);
  return { Fp: n, Fn: i };
}
export {
  G as _createCurveFields,
  $ as mulEndoUnsafe,
  b as negateCt,
  L as normalizeZ,
  D as pippenger,
  U as wNAF
};
