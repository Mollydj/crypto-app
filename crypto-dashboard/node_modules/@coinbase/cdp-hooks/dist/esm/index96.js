import { BaseError as $ } from "./index107.js";
import { HttpRequestError as M } from "./index38.js";
import { MethodNotSupportedRpcError as c, UnknownRpcError as g, UserRejectedRequestError as s, AtomicityNotSupportedError as h, AtomicReadyWalletRejectedUpgradeError as p, BundleTooLargeError as f, UnknownBundleIdError as E, DuplicateIdError as m, UnsupportedChainIdError as l, UnsupportedNonOptionalCapabilityError as R, SwitchChainError as y, ChainDisconnectedError as I, ProviderDisconnectedError as U, UnsupportedProviderMethodError as v, UnauthorizedProviderError as b, JsonRpcVersionUnsupportedError as N, LimitExceededRpcError as u, TransactionRejectedRpcError as q, ResourceUnavailableRpcError as C, ResourceNotFoundRpcError as D, InvalidInputRpcError as P, InternalRpcError as a, InvalidParamsRpcError as x, MethodNotFoundRpcError as A, InvalidRequestRpcError as j, ParseRpcError as B } from "./index121.js";
import { stringToHex as z } from "./index134.js";
import { withDedupe as J } from "./index262.js";
import { withRetry as O } from "./index200.js";
import { stringify as V } from "./index128.js";
function ee(r, S = {}) {
  return async (o, T = {}) => {
    const { dedupe: i = !1, methods: d, retryDelay: k = 150, retryCount: F = 3, uid: H } = {
      ...S,
      ...T
    }, { method: n } = o;
    if (d?.exclude?.includes(n))
      throw new c(new Error("method not supported"), {
        method: n
      });
    if (d?.include && !d.include.includes(n))
      throw new c(new Error("method not supported"), {
        method: n
      });
    const L = i ? z(`${H}.${V(o)}`) : void 0;
    return J(() => O(async () => {
      try {
        return await r(o);
      } catch (t) {
        const e = t;
        switch (e.code) {
          // -32700
          case B.code:
            throw new B(e);
          // -32600
          case j.code:
            throw new j(e);
          // -32601
          case A.code:
            throw new A(e, { method: o.method });
          // -32602
          case x.code:
            throw new x(e);
          // -32603
          case a.code:
            throw new a(e);
          // -32000
          case P.code:
            throw new P(e);
          // -32001
          case D.code:
            throw new D(e);
          // -32002
          case C.code:
            throw new C(e);
          // -32003
          case q.code:
            throw new q(e);
          // -32004
          case c.code:
            throw new c(e, {
              method: o.method
            });
          // -32005
          case u.code:
            throw new u(e);
          // -32006
          case N.code:
            throw new N(e);
          // 4001
          case s.code:
            throw new s(e);
          // 4100
          case b.code:
            throw new b(e);
          // 4200
          case v.code:
            throw new v(e);
          // 4900
          case U.code:
            throw new U(e);
          // 4901
          case I.code:
            throw new I(e);
          // 4902
          case y.code:
            throw new y(e);
          // 5700
          case R.code:
            throw new R(e);
          // 5710
          case l.code:
            throw new l(e);
          // 5720
          case m.code:
            throw new m(e);
          // 5730
          case E.code:
            throw new E(e);
          // 5740
          case f.code:
            throw new f(e);
          // 5750
          case p.code:
            throw new p(e);
          // 5760
          case h.code:
            throw new h(e);
          // CAIP-25: User Rejected Error
          // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
          case 5e3:
            throw new s(e);
          default:
            throw t instanceof $ ? t : new g(e);
        }
      }
    }, {
      delay: ({ count: t, error: e }) => {
        if (e && e instanceof M) {
          const w = e?.headers?.get("Retry-After");
          if (w?.match(/\d/))
            return Number.parseInt(w) * 1e3;
        }
        return ~~(1 << t) * k;
      },
      retryCount: F,
      shouldRetry: ({ error: t }) => W(t)
    }), { enabled: i, id: L });
  };
}
function W(r) {
  return "code" in r && typeof r.code == "number" ? r.code === -1 || r.code === u.code || r.code === a.code : r instanceof M && r.status ? r.status === 403 || r.status === 408 || r.status === 413 || r.status === 429 || r.status === 500 || r.status === 502 || r.status === 503 || r.status === 504 : !0;
}
export {
  ee as buildRequest,
  W as shouldRetry
};
