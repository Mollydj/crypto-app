import { universalSignatureValidatorAbi as d } from "./index97.js";
import { universalSignatureValidatorByteCode as l } from "./index99.js";
import { CallExecutionError as g } from "./index110.js";
import { encodeDeployData as y } from "./index159.js";
import { getAddress as S } from "./index144.js";
import { isAddressEqual as h } from "./index166.js";
import { isHex as v } from "./index170.js";
import { bytesToHex as x } from "./index134.js";
import { getAction as b } from "./index237.js";
import { isErc6492Signature as A } from "./index180.js";
import { recoverAddress as w } from "./index174.js";
import { serializeErc6492Signature as E } from "./index181.js";
import { serializeSignature as V } from "./index178.js";
import { call as D } from "./index49.js";
import { encodeFunctionData as H } from "./index162.js";
import { hexToBool as z } from "./index167.js";
async function Q(o, p) {
  const { address: i, factory: n, factoryData: s, hash: a, signature: r, universalSignatureVerifierAddress: f = o.chain?.contracts?.universalSignatureVerifier?.address, ...m } = p, t = v(r) ? r : typeof r == "object" && "r" in r && "s" in r ? V(r) : x(r), c = await (async () => !n && !s || A(t) ? t : E({
    address: n,
    data: s,
    signature: t
  }))();
  try {
    const e = f ? {
      to: f,
      data: H({
        abi: d,
        functionName: "isValidSig",
        args: [i, a, c]
      }),
      ...m
    } : {
      data: y({
        abi: d,
        args: [i, a, c],
        bytecode: l
      }),
      ...m
    }, { data: u } = await b(o, D, "call")(e);
    return z(u ?? "0x0");
  } catch (e) {
    try {
      if (h(S(i), await w({ hash: a, signature: r })))
        return !0;
    } catch {
    }
    if (e instanceof g)
      return !1;
    throw e;
  }
}
export {
  Q as verifyHash
};
