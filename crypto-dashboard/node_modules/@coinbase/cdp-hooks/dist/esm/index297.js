import { BaseError as c } from "./index289.js";
import { padRight as h } from "./index277.js";
import { charCodeToBase16 as b, assertSize as g, pad as m } from "./index298.js";
import { assertSize as p } from "./index291.js";
const l = /* @__PURE__ */ new TextEncoder();
function E(e) {
  return e instanceof Uint8Array ? e : typeof e == "string" ? y(e) : z(e);
}
function z(e) {
  return e instanceof Uint8Array ? e : new Uint8Array(e);
}
function y(e, t = {}) {
  const { size: r } = t;
  let n = e;
  r && (p(e, r), n = h(e, r));
  let i = n.slice(2);
  i.length % 2 && (i = `0${i}`);
  const f = i.length / 2, a = new Uint8Array(f);
  for (let s = 0, o = 0; s < f; s++) {
    const d = b(i.charCodeAt(o++)), u = b(i.charCodeAt(o++));
    if (d === void 0 || u === void 0)
      throw new c(`Invalid byte sequence ("${i[o - 2]}${i[o - 1]}" in "${i}").`);
    a[s] = d * 16 + u;
  }
  return a;
}
function C(e, t = {}) {
  const { size: r } = t, n = l.encode(e);
  return typeof r == "number" ? (g(n, r), x(n, r)) : n;
}
function x(e, t) {
  return m(e, { dir: "right", size: t });
}
function U(e) {
  return e.length;
}
class B extends c {
  constructor({ givenSize: t, maxSize: r }) {
    super(`Size cannot exceed \`${r}\` bytes. Given size: \`${t}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeOverflowError"
    });
  }
}
class O extends c {
  constructor({ size: t, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${r}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
}
export {
  O as SizeExceedsPaddingSizeError,
  B as SizeOverflowError,
  E as from,
  z as fromArray,
  y as fromHex,
  C as fromString,
  x as padRight,
  U as size
};
