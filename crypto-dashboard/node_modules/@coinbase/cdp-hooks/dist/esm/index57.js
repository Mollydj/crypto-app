import { parseAccount as R } from "./index36.js";
import { BaseError as _ } from "./index107.js";
import { recoverAuthorizationAddress as A } from "./index251.js";
import { numberToHex as x } from "./index134.js";
import { getEstimateGasError as E } from "./index252.js";
import { extract as N } from "./index249.js";
import { formatTransactionRequest as S } from "./index169.js";
import { serializeStateOverride as I } from "./index250.js";
import { assertRequest as V } from "./index182.js";
import { prepareTransactionRequest as C } from "./index94.js";
import { getBalance as j } from "./index59.js";
async function rt(t, s) {
  const { account: u = t.account } = s, i = u ? R(u) : void 0;
  try {
    let w = function(m) {
      const { block: o, request: e, rpcStateOverride: a } = m;
      return t.request({
        method: "eth_estimateGas",
        params: a ? [
          e,
          o ?? t.experimental_blockTag ?? "latest",
          a
        ] : o ? [e, o] : [e]
      });
    };
    const { accessList: n, authorizationList: r, blobs: v, blobVersionedHashes: g, blockNumber: f, blockTag: k, data: d, gas: y, gasPrice: G, maxFeePerBlobGas: z, maxFeePerGas: P, maxPriorityFeePerGas: B, nonce: H, value: T, stateOverride: F, ...c } = await C(t, {
      ...s,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        i?.type === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), p = (typeof f == "bigint" ? x(f) : void 0) || k, b = I(F), L = await (async () => {
      if (c.to)
        return c.to;
      if (r && r.length > 0)
        return await A({
          authorization: r[0]
        }).catch(() => {
          throw new _("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    V(s);
    const h = t.chain?.formatters?.transactionRequest?.format, l = (h || S)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...N(c, { format: h }),
      from: i?.address,
      accessList: n,
      authorizationList: r,
      blobs: v,
      blobVersionedHashes: g,
      data: d,
      gas: y,
      gasPrice: G,
      maxFeePerBlobGas: z,
      maxFeePerGas: P,
      maxPriorityFeePerGas: B,
      nonce: H,
      to: L,
      value: T
    });
    let q = BigInt(await w({ block: p, request: l, rpcStateOverride: b }));
    if (r) {
      const m = await j(t, { address: l.from }), o = await Promise.all(r.map(async (e) => {
        const { address: a } = e, O = await w({
          block: p,
          request: {
            authorizationList: void 0,
            data: d,
            from: i?.address,
            to: a,
            value: x(m)
          },
          rpcStateOverride: b
        }).catch(() => 100000n);
        return 2n * BigInt(O);
      }));
      q += o.reduce((e, a) => e + a, 0n);
    }
    return q;
  } catch (n) {
    throw E(n, {
      ...s,
      account: i,
      chain: t.chain
    });
  }
}
export {
  rt as estimateGas
};
