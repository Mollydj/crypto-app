import { AbiItemAmbiguityError as y } from "./index104.js";
import { isHex as d } from "./index170.js";
import { isAddress as f } from "./index156.js";
import { toEventSelector as g } from "./index152.js";
import { toFunctionSelector as b } from "./index150.js";
function x(s) {
  const { abi: o, args: n = [], name: e } = s, u = d(e, { strict: !1 }), i = o.filter((t) => u ? t.type === "function" ? b(t) === e : t.type === "event" ? g(t) === e : !1 : "name" in t && t.name === e);
  if (i.length === 0)
    return;
  if (i.length === 1)
    return i[0];
  let r;
  for (const t of i) {
    if (!("inputs" in t))
      continue;
    if (!n || n.length === 0) {
      if (!t.inputs || t.inputs.length === 0)
        return t;
      continue;
    }
    if (!t.inputs || t.inputs.length === 0 || t.inputs.length !== n.length)
      continue;
    if (n.every((c, m) => {
      const l = "inputs" in t && t.inputs[m];
      return l ? p(c, l) : !1;
    })) {
      if (r && "inputs" in r && r.inputs) {
        const c = a(t.inputs, r.inputs, n);
        if (c)
          throw new y({
            abiItem: t,
            type: c[0]
          }, {
            abiItem: r,
            type: c[1]
          });
      }
      r = t;
    }
  }
  return r || i[0];
}
function p(s, o) {
  const n = typeof s, e = o.type;
  switch (e) {
    case "address":
      return f(s, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return e === "tuple" && "components" in o ? Object.values(o.components).every((u, i) => p(Object.values(s)[i], u)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(e) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(e) ? n === "string" || s instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(e) ? Array.isArray(s) && s.every((u) => p(u, {
        ...o,
        // Pop off `[]` or `[M]` from end of type
        type: e.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function a(s, o, n) {
  for (const e in s) {
    const u = s[e], i = o[e];
    if (u.type === "tuple" && i.type === "tuple" && "components" in u && "components" in i)
      return a(u.components, i.components, n[e]);
    const r = [u.type, i.type];
    if (r.includes("address") && r.includes("bytes20") ? !0 : r.includes("address") && r.includes("string") ? f(n[e], { strict: !1 }) : r.includes("address") && r.includes("bytes") ? f(n[e], { strict: !1 }) : !1)
      return r;
  }
}
export {
  x as getAbiItem,
  a as getAmbiguousTypes,
  p as isArgOfType
};
