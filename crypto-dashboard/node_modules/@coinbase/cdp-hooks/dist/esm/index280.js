import { BaseError as y } from "./index289.js";
import { keccak256 as v } from "./index292.js";
import { validate as $, slice as A, fromString as S } from "./index277.js";
import { isArgOfType as E, normalizeSignature as p, getAmbiguousTypes as B } from "./index293.js";
import { parseAbiItem as l } from "./index231.js";
import { formatAbiItem as h } from "./index223.js";
function H(e, r = {}) {
  const { prepare: i = !0 } = r, n = Array.isArray(e) ? l(e) : typeof e == "string" ? l(e) : e;
  return {
    ...n,
    ...i ? { hash: s(n) } : {}
  };
}
function M(e, r, i) {
  const { args: n = [], prepare: f = !0 } = i ?? {}, b = $(r, { strict: !1 }), u = e.filter((t) => b ? t.type === "function" || t.type === "error" ? T(t) === A(r, 0, 4) : t.type === "event" ? s(t) === r : !1 : "name" in t && t.name === r);
  if (u.length === 0)
    throw new d({ name: r });
  if (u.length === 1)
    return {
      ...u[0],
      ...f ? { hash: s(u[0]) } : {}
    };
  let o;
  for (const t of u) {
    if (!("inputs" in t))
      continue;
    if (!n || n.length === 0) {
      if (!t.inputs || t.inputs.length === 0)
        return {
          ...t,
          ...f ? { hash: s(t) } : {}
        };
      continue;
    }
    if (!t.inputs || t.inputs.length === 0 || t.inputs.length !== n.length)
      continue;
    if (n.every((a, w) => {
      const g = "inputs" in t && t.inputs[w];
      return g ? E(a, g) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const a = B(t.inputs, o.inputs, n);
        if (a)
          throw new O({
            abiItem: t,
            type: a[0]
          }, {
            abiItem: o,
            type: a[1]
          });
      }
      o = t;
    }
  }
  const c = (() => {
    if (o)
      return o;
    const [t, ...m] = u;
    return { ...t, overloads: m };
  })();
  if (!c)
    throw new d({ name: r });
  return {
    ...c,
    ...f ? { hash: s(c) } : {}
  };
}
function T(e) {
  return A(s(e), 0, 4);
}
function F(e) {
  const r = typeof e == "string" ? e : h(e);
  return p(r);
}
function s(e) {
  return typeof e != "string" && "hash" in e && e.hash ? e.hash : v(S(F(e)));
}
class O extends y {
  constructor(r, i) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        // TODO: abitype to add support for signature-formatted ABI items.
        `\`${r.type}\` in \`${p(h(r.abiItem))}\`, and`,
        `\`${i.type}\` in \`${p(h(i.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.AmbiguityError"
    });
  }
}
class d extends y {
  constructor({ name: r, data: i, type: n = "item" }) {
    const f = r ? ` with name "${r}"` : i ? ` with data "${i}"` : "";
    super(`ABI ${n}${f} not found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.NotFoundError"
    });
  }
}
export {
  O as AmbiguityError,
  d as NotFoundError,
  H as from,
  M as fromAbi,
  T as getSelector,
  F as getSignature,
  s as getSignatureHash
};
