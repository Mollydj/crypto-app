import { parseAccount as x } from "./index36.js";
import { internal_estimateFeesPerGas as P } from "./index56.js";
import { estimateGas as F } from "./index57.js";
import { getBlock as I } from "./index61.js";
import { getTransactionCount as T } from "./index77.js";
import { MaxFeePerGasTooLowError as C, Eip1559FeesNotSupportedError as H } from "./index120.js";
import { blobsToCommitments as q } from "./index189.js";
import { blobsToProofs as V } from "./index193.js";
import { commitmentsToVersionedHashes as _ } from "./index192.js";
import { toBlobSidecars as B } from "./index194.js";
import { getAction as p } from "./index237.js";
import { assertRequest as E } from "./index182.js";
import { getTransactionType as M } from "./index171.js";
import { getChainId as N } from "./index64.js";
const A = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
], w = /* @__PURE__ */ new Map();
async function X(t, a) {
  const { account: u = t.account, blobs: c, chain: d, gas: g, kzg: y, nonce: G, nonceManager: b, parameters: s = A, type: k } = a, i = u && x(u), e = { ...a, ...i ? { from: i?.address } : {} };
  let f;
  async function l() {
    return f || (f = await p(t, I, "getBlock")({ blockTag: "latest" }), f);
  }
  let m;
  async function h() {
    return m || (d ? d.id : typeof a.chainId < "u" ? a.chainId : (m = await p(t, N, "getChainId")({}), m));
  }
  if (s.includes("nonce") && typeof G > "u" && i)
    if (b) {
      const o = await h();
      e.nonce = await b.consume({
        address: i.address,
        chainId: o,
        client: t
      });
    } else
      e.nonce = await p(t, T, "getTransactionCount")({
        address: i.address,
        blockTag: "pending"
      });
  if ((s.includes("blobVersionedHashes") || s.includes("sidecars")) && c && y) {
    const o = q({ blobs: c, kzg: y });
    if (s.includes("blobVersionedHashes")) {
      const n = _({
        commitments: o,
        to: "hex"
      });
      e.blobVersionedHashes = n;
    }
    if (s.includes("sidecars")) {
      const n = V({ blobs: c, commitments: o, kzg: y }), r = B({
        blobs: c,
        commitments: o,
        proofs: n,
        to: "hex"
      });
      e.sidecars = r;
    }
  }
  if (s.includes("chainId") && (e.chainId = await h()), (s.includes("fees") || s.includes("type")) && typeof k > "u")
    try {
      e.type = M(e);
    } catch {
      let o = w.get(t.uid);
      typeof o > "u" && (o = typeof (await l())?.baseFeePerGas == "bigint", w.set(t.uid, o)), e.type = o ? "eip1559" : "legacy";
    }
  if (s.includes("fees"))
    if (e.type !== "legacy" && e.type !== "eip2930") {
      if (typeof e.maxFeePerGas > "u" || typeof e.maxPriorityFeePerGas > "u") {
        const o = await l(), { maxFeePerGas: n, maxPriorityFeePerGas: r } = await P(t, {
          block: o,
          chain: d,
          request: e
        });
        if (typeof a.maxPriorityFeePerGas > "u" && a.maxFeePerGas && a.maxFeePerGas < r)
          throw new C({
            maxPriorityFeePerGas: r
          });
        e.maxPriorityFeePerGas = r, e.maxFeePerGas = n;
      }
    } else {
      if (typeof a.maxFeePerGas < "u" || typeof a.maxPriorityFeePerGas < "u")
        throw new H();
      if (typeof a.gasPrice > "u") {
        const o = await l(), { gasPrice: n } = await P(t, {
          block: o,
          chain: d,
          request: e,
          type: "legacy"
        });
        e.gasPrice = n;
      }
    }
  return s.includes("gas") && typeof g > "u" && (e.gas = await p(t, F, "estimateGas")({
    ...e,
    account: i && { address: i.address, type: "json-rpc" }
  })), E(e), delete e.parameters, e;
}
export {
  A as defaultParameters,
  w as eip1559NetworkCache,
  X as prepareTransactionRequest
};
