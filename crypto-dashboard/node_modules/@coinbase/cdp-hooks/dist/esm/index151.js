import { AbiEventSignatureEmptyTopicsError as A, AbiEventSignatureNotFoundError as x, DecodeLogTopicsMismatch as D, AbiDecodingDataSizeTooSmallError as I, DecodeLogDataMismatch as h } from "./index104.js";
import { size as S } from "./index106.js";
import { toEventSelector as T } from "./index152.js";
import { PositionOutOfBoundsError as z } from "./index153.js";
import { decodeAbiParameters as w } from "./index143.js";
import { formatAbiItem as L } from "./index105.js";
const l = "/docs/contract/decodeEventLog";
function U(n) {
  const { abi: c, data: i, strict: E, topics: b } = n, m = E ?? !0, [a, ...v] = b;
  if (!a)
    throw new A({ docsPath: l });
  const o = c.find((e) => e.type === "event" && a === T(L(e)));
  if (!(o && "name" in o) || o.type !== "event")
    throw new x(a, { docsPath: l });
  const { name: y, inputs: d } = o, f = d?.some((e) => !("name" in e && e.name)), r = f ? [] : {}, p = d.map((e, t) => [e, t]).filter(([e]) => "indexed" in e && e.indexed);
  for (let e = 0; e < p.length; e++) {
    const [t, g] = p[e], u = v[e];
    if (!u)
      throw new D({
        abiItem: o,
        param: t
      });
    r[f ? g : t.name || g] = O({
      param: t,
      value: u
    });
  }
  const s = d.filter((e) => !("indexed" in e && e.indexed));
  if (s.length > 0) {
    if (i && i !== "0x")
      try {
        const e = w(s, i);
        if (e)
          if (f)
            for (let t = 0; t < d.length; t++)
              r[t] = r[t] ?? e.shift();
          else
            for (let t = 0; t < s.length; t++)
              r[s[t].name] = e[t];
      } catch (e) {
        if (m)
          throw e instanceof I || e instanceof z ? new h({
            abiItem: o,
            data: i,
            params: s,
            size: S(i)
          }) : e;
      }
    else if (m)
      throw new h({
        abiItem: o,
        data: "0x",
        params: s,
        size: 0
      });
  }
  return {
    eventName: y,
    args: Object.values(r).length > 0 ? r : void 0
  };
}
function O({ param: n, value: c }) {
  return n.type === "string" || n.type === "bytes" || n.type === "tuple" || n.type.match(/^(.*)\[(\d+)?\]$/) ? c : (w([n], c) || [])[0];
}
export {
  U as decodeEventLog
};
