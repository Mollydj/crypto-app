import { multicall3Abi as x } from "./index97.js";
import { AbiDecodingZeroDataError as P } from "./index104.js";
import { BaseError as _ } from "./index107.js";
import { RawContractError as v } from "./index110.js";
import { decodeFunctionResult as q } from "./index155.js";
import { encodeFunctionData as B } from "./index162.js";
import { getChainContractAddress as O } from "./index198.js";
import { getContractError as E } from "./index205.js";
import { getAction as T } from "./index237.js";
import { readContract as Z } from "./index80.js";
async function W(n, w) {
  const { account: b, allowFailure: u = !0, batchSize: F, blockNumber: p, blockTag: j, multicallAddress: y, stateOverride: N } = w, d = w.contracts, C = F ?? (typeof n.batch?.multicall == "object" && n.batch.multicall.batchSize || 1024);
  let m = y;
  if (!m) {
    if (!n.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    m = O({
      blockNumber: p,
      chain: n.chain,
      contract: "multicall3"
    });
  }
  const e = [[]];
  let a = 0, f = 0;
  for (let t = 0; t < d.length; t++) {
    const { abi: o, address: s, args: r, functionName: i } = d[t];
    try {
      const c = B({ abi: o, args: r, functionName: i });
      f += (c.length - 2) / 2, // Check if batching is enabled.
      C > 0 && // Check if the current size of the batch exceeds the size limit.
      f > C && // Check if the current chunk is not already empty.
      e[a].length > 0 && (a++, f = (c.length - 2) / 2, e[a] = []), e[a] = [
        ...e[a],
        {
          allowFailure: !0,
          callData: c,
          target: s
        }
      ];
    } catch (c) {
      const g = E(c, {
        abi: o,
        address: s,
        args: r,
        docsPath: "/docs/contract/multicall",
        functionName: i,
        sender: b
      });
      if (!u)
        throw g;
      e[a] = [
        ...e[a],
        {
          allowFailure: !0,
          callData: "0x",
          target: s
        }
      ];
    }
  }
  const A = await Promise.allSettled(e.map((t) => T(n, Z, "readContract")({
    abi: x,
    account: b,
    address: m,
    args: [t],
    blockNumber: p,
    blockTag: j,
    functionName: "aggregate3",
    stateOverride: N
  }))), l = [];
  for (let t = 0; t < A.length; t++) {
    const o = A[t];
    if (o.status === "rejected") {
      if (!u)
        throw o.reason;
      for (let r = 0; r < e[t].length; r++)
        l.push({
          status: "failure",
          error: o.reason,
          result: void 0
        });
      continue;
    }
    const s = o.value;
    for (let r = 0; r < s.length; r++) {
      const { returnData: i, success: c } = s[r], { callData: g } = e[t][r], { abi: D, address: R, functionName: S, args: k } = d[l.length];
      try {
        if (g === "0x")
          throw new P();
        if (!c)
          throw new v({ data: i });
        const h = q({
          abi: D,
          args: k,
          data: i,
          functionName: S
        });
        l.push(u ? { result: h, status: "success" } : h);
      } catch (h) {
        const z = E(h, {
          abi: D,
          address: R,
          args: k,
          docsPath: "/docs/contract/multicall",
          functionName: S
        });
        if (!u)
          throw z;
        l.push({ error: z, result: void 0, status: "failure" });
      }
    }
  }
  if (l.length !== d.length)
    throw new _("multicall results mismatch");
  return l;
}
export {
  W as multicall
};
