import { BlockNotFoundError as D } from "./index109.js";
import { WaitForTransactionReceiptTimeoutError as M, TransactionNotFoundError as O, TransactionReceiptNotFoundError as W } from "./index118.js";
import { getAction as l } from "./index237.js";
import { observe as q } from "./index239.js";
import { withResolvers as z } from "./index241.js";
import { withRetry as B } from "./index200.js";
import { stringify as G } from "./index128.js";
import { getBlock as H } from "./index61.js";
import { getTransaction as J } from "./index75.js";
import { getTransactionReceipt as g } from "./index78.js";
import { watchBlockNumber as K } from "./index88.js";
async function re(r, b) {
  const {
    checkReplacement: F = !0,
    confirmations: n = 1,
    hash: s,
    onReplaced: _,
    retryCount: v = 6,
    retryDelay: y = ({ count: t }) => ~~(1 << t) * 200,
    // exponential backoff
    timeout: N = 18e4
  } = b, I = G(["waitForTransactionReceipt", r.uid, s]), E = b.pollingInterval ? b.pollingInterval : r.chain?.experimental_preconfirmationTime ? r.chain.experimental_preconfirmationTime : r.pollingInterval;
  let i, a, e, c = !1, p, d;
  const { promise: j, resolve: x, reject: R } = z(), w = N ? setTimeout(() => {
    d(), p(), R(new M({ hash: s }));
  }, N) : void 0;
  return p = q(I, { onReplaced: _, resolve: x, reject: R }, async (t) => {
    if (e = await l(r, g, "getTransactionReceipt")({ hash: s }).catch(() => {
    }), e && n <= 1) {
      clearTimeout(w), t.resolve(e), p();
      return;
    }
    d = l(r, K, "watchBlockNumber")({
      emitMissed: !0,
      emitOnBegin: !0,
      poll: !0,
      pollingInterval: E,
      async onBlockNumber(A) {
        const u = (f) => {
          clearTimeout(w), d(), f(), p();
        };
        let m = A;
        if (!c)
          try {
            if (e) {
              if (n > 1 && (!e.blockNumber || m - e.blockNumber + 1n < n))
                return;
              u(() => t.resolve(e));
              return;
            }
            if (F && !i && (c = !0, await B(async () => {
              i = await l(r, J, "getTransaction")({ hash: s }), i.blockNumber && (m = i.blockNumber);
            }, {
              delay: y,
              retryCount: v
            }), c = !1), e = await l(r, g, "getTransactionReceipt")({ hash: s }), n > 1 && (!e.blockNumber || m - e.blockNumber + 1n < n))
              return;
            u(() => t.resolve(e));
          } catch (f) {
            if (f instanceof O || f instanceof W) {
              if (!i) {
                c = !1;
                return;
              }
              try {
                a = i, c = !0;
                const T = await B(() => l(r, H, "getBlock")({
                  blockNumber: m,
                  includeTransactions: !0
                }), {
                  delay: y,
                  retryCount: v,
                  shouldRetry: ({ error: k }) => k instanceof D
                });
                c = !1;
                const o = T.transactions.find(({ from: k, nonce: C }) => k === a.from && C === a.nonce);
                if (!o || (e = await l(r, g, "getTransactionReceipt")({
                  hash: o.hash
                }), n > 1 && (!e.blockNumber || m - e.blockNumber + 1n < n)))
                  return;
                let h = "replaced";
                o.to === a.to && o.value === a.value && o.input === a.input ? h = "repriced" : o.from === o.to && o.value === 0n && (h = "cancelled"), u(() => {
                  t.onReplaced?.({
                    reason: h,
                    replacedTransaction: a,
                    transaction: o,
                    transactionReceipt: e
                  }), t.resolve(e);
                });
              } catch (T) {
                u(() => t.reject(T));
              }
            } else
              u(() => t.reject(f));
          }
      }
    });
  }), j;
}
export {
  re as waitForTransactionReceipt
};
