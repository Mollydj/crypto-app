import { AbiDecodingZeroDataError as a, AbiDecodingDataSizeTooSmallError as C, InvalidAbiDecodingTypeError as D } from "./index104.js";
import { checksumAddress as w } from "./index144.js";
import { createCursor as _ } from "./index145.js";
import { size as p } from "./index106.js";
import { sliceBytes as W } from "./index146.js";
import { trim as x } from "./index147.js";
import { bytesToNumber as y, bytesToBool as I, bytesToBigInt as N, bytesToString as O } from "./index148.js";
import { hexToBytes as S } from "./index133.js";
import { bytesToHex as g } from "./index134.js";
import { getArrayComponents as A } from "./index149.js";
function Y(t, e) {
  const n = typeof e == "string" ? S(e) : e, i = _(n);
  if (p(n) === 0 && t.length > 0)
    throw new a();
  if (p(e) && p(e) < 32)
    throw new C({
      data: typeof e == "string" ? e : g(e),
      params: t,
      size: p(e)
    });
  let s = 0;
  const d = [];
  for (let o = 0; o < t.length; ++o) {
    const r = t[o];
    i.setPosition(s);
    const [f, c] = u(i, r, {
      staticPosition: 0
    });
    s += c, d.push(f);
  }
  return d;
}
function u(t, e, { staticPosition: n }) {
  const i = A(e.type);
  if (i) {
    const [s, d] = i;
    return k(t, { ...e, type: d }, { length: s, staticPosition: n });
  }
  if (e.type === "tuple")
    return Z(t, e, { staticPosition: n });
  if (e.type === "address")
    return E(t);
  if (e.type === "bool")
    return H(t);
  if (e.type.startsWith("bytes"))
    return L(t, e, { staticPosition: n });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return U(t, e);
  if (e.type === "string")
    return j(t, { staticPosition: n });
  throw new D(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const P = 32, b = 32;
function E(t) {
  const e = t.readBytes(32);
  return [w(g(W(e, -20))), 32];
}
function k(t, e, { length: n, staticPosition: i }) {
  if (!n) {
    const o = y(t.readBytes(b)), r = i + o, f = r + P;
    t.setPosition(r);
    const c = y(t.readBytes(P)), l = m(e);
    let h = 0;
    const v = [];
    for (let B = 0; B < c; ++B) {
      t.setPosition(f + (l ? B * 32 : h));
      const [T, z] = u(t, e, {
        staticPosition: f
      });
      h += z, v.push(T);
    }
    return t.setPosition(i + 32), [v, 32];
  }
  if (m(e)) {
    const o = y(t.readBytes(b)), r = i + o, f = [];
    for (let c = 0; c < n; ++c) {
      t.setPosition(r + c * 32);
      const [l] = u(t, e, {
        staticPosition: r
      });
      f.push(l);
    }
    return t.setPosition(i + 32), [f, 32];
  }
  let s = 0;
  const d = [];
  for (let o = 0; o < n; ++o) {
    const [r, f] = u(t, e, {
      staticPosition: i + s
    });
    s += f, d.push(r);
  }
  return [d, s];
}
function H(t) {
  return [I(t.readBytes(32), { size: 32 }), 32];
}
function L(t, e, { staticPosition: n }) {
  const [i, s] = e.type.split("bytes");
  if (!s) {
    const o = y(t.readBytes(32));
    t.setPosition(n + o);
    const r = y(t.readBytes(32));
    if (r === 0)
      return t.setPosition(n + 32), ["0x", 32];
    const f = t.readBytes(r);
    return t.setPosition(n + 32), [g(f), 32];
  }
  return [g(t.readBytes(Number.parseInt(s), 32)), 32];
}
function U(t, e) {
  const n = e.type.startsWith("int"), i = Number.parseInt(e.type.split("int")[1] || "256"), s = t.readBytes(32);
  return [
    i > 48 ? N(s, { signed: n }) : y(s, { signed: n }),
    32
  ];
}
function Z(t, e, { staticPosition: n }) {
  const i = e.components.length === 0 || e.components.some(({ name: o }) => !o), s = i ? [] : {};
  let d = 0;
  if (m(e)) {
    const o = y(t.readBytes(b)), r = n + o;
    for (let f = 0; f < e.components.length; ++f) {
      const c = e.components[f];
      t.setPosition(r + d);
      const [l, h] = u(t, c, {
        staticPosition: r
      });
      d += h, s[i ? f : c?.name] = l;
    }
    return t.setPosition(n + 32), [s, 32];
  }
  for (let o = 0; o < e.components.length; ++o) {
    const r = e.components[o], [f, c] = u(t, r, {
      staticPosition: n
    });
    s[i ? o : r?.name] = f, d += c;
  }
  return [s, d];
}
function j(t, { staticPosition: e }) {
  const n = y(t.readBytes(32)), i = e + n;
  t.setPosition(i);
  const s = y(t.readBytes(32));
  if (s === 0)
    return t.setPosition(e + 32), ["", 32];
  const d = t.readBytes(s, 32), o = O(x(d));
  return t.setPosition(e + 32), [o, 32];
}
function m(t) {
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return t.components?.some(m);
  const n = A(t.type);
  return !!(n && m({ ...t, type: n[1] }));
}
export {
  Y as decodeAbiParameters
};
