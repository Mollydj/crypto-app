import { getAction as p } from "./index237.js";
import { observe as h } from "./index239.js";
import { poll as v } from "./index240.js";
import { stringify as S } from "./index128.js";
import { getBlock as i } from "./index61.js";
function P(r, { blockTag: l = r.experimental_blockTag ?? "latest", emitMissed: y = !1, emitOnBegin: m = !1, onBlock: k, onError: f, includeTransactions: B, poll: d, pollingInterval: w = r.pollingInterval }) {
  const g = typeof d < "u" ? d : !(r.transport.type === "webSocket" || r.transport.type === "ipc" || r.transport.type === "fallback" && (r.transport.transports[0].config.type === "webSocket" || r.transport.transports[0].config.type === "ipc")), a = B ?? !1;
  let e;
  return g ? (() => {
    const o = S([
      "watchBlocks",
      r.uid,
      l,
      y,
      m,
      a,
      w
    ]);
    return h(o, { onBlock: k, onError: f }, (s) => v(async () => {
      try {
        const t = await p(r, i, "getBlock")({
          blockTag: l,
          includeTransactions: a
        });
        if (t.number !== null && e?.number != null) {
          if (t.number === e.number)
            return;
          if (t.number - e.number > 1 && y)
            for (let u = e?.number + 1n; u < t.number; u++) {
              const b = await p(r, i, "getBlock")({
                blockNumber: u,
                includeTransactions: a
              });
              s.onBlock(b, e), e = b;
            }
        }
        // If no previous block exists, emit.
        (e?.number == null || // If the block tag is "pending" with no block number, emit.
        l === "pending" && t?.number == null || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        t.number !== null && t.number > e.number) && (s.onBlock(t, e), e = t);
      } catch (t) {
        s.onError?.(t);
      }
    }, {
      emitOnBegin: m,
      interval: w
    }));
  })() : (() => {
    let o = !0, s = !0, t = () => o = !1;
    return (async () => {
      try {
        m && p(r, i, "getBlock")({
          blockTag: l,
          includeTransactions: a
        }).then((n) => {
          o && s && (k(n, void 0), s = !1);
        }).catch(f);
        const u = (() => {
          if (r.transport.type === "fallback") {
            const n = r.transport.transports.find((c) => c.config.type === "webSocket" || c.config.type === "ipc");
            return n ? n.value : r.transport;
          }
          return r.transport;
        })(), { unsubscribe: b } = await u.subscribe({
          params: ["newHeads"],
          async onData(n) {
            if (!o)
              return;
            const c = await p(r, i, "getBlock")({
              blockNumber: n.result?.number,
              includeTransactions: a
            }).catch(() => {
            });
            o && (k(c, e), s = !1, e = c);
          },
          onError(n) {
            f?.(n);
          }
        });
        t = b, o || t();
      } catch (u) {
        f?.(u);
      }
    })(), () => t();
  })();
}
export {
  P as watchBlocks
};
