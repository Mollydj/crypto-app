import { toRpc as R } from "./index246.js";
import { parseAccount as q } from "./index36.js";
import { AbiDecodingZeroDataError as D } from "./index104.js";
import { RawContractError as S } from "./index110.js";
import { UnknownNodeError as y } from "./index126.js";
import { decodeFunctionResult as B } from "./index155.js";
import { encodeFunctionData as C } from "./index162.js";
import { concat as F } from "./index138.js";
import { numberToHex as H } from "./index134.js";
import { getContractError as U } from "./index205.js";
import { getNodeError as A } from "./index256.js";
import { formatBlock as _ } from "./index139.js";
import { formatLog as z } from "./index142.js";
import { formatTransactionRequest as I } from "./index169.js";
import { serializeStateOverride as L } from "./index250.js";
import { assertRequest as V } from "./index182.js";
async function nr(p, g) {
  const { blockNumber: b, blockTag: x = p.experimental_blockTag ?? "latest", blocks: k, returnFullTransactions: v, traceTransfers: w, validation: N } = g;
  try {
    const a = [];
    for (const o of k) {
      const d = o.blockOverrides ? R(o.blockOverrides) : void 0, t = o.calls.map((n) => {
        const r = n, i = r.account ? q(r.account) : void 0, m = r.abi ? C(r) : r.data, e = {
          ...r,
          data: r.dataSuffix ? F([m || "0x", r.dataSuffix]) : m,
          from: r.from ?? i?.address
        };
        return V(e), I(e);
      }), l = o.stateOverrides ? L(o.stateOverrides) : void 0;
      a.push({
        blockOverrides: d,
        calls: t,
        stateOverrides: l
      });
    }
    const c = (typeof b == "bigint" ? H(b) : void 0) || x;
    return (await p.request({
      method: "eth_simulateV1",
      params: [
        { blockStateCalls: a, returnFullTransactions: v, traceTransfers: w, validation: N },
        c
      ]
    })).map((o, d) => ({
      ..._(o),
      calls: o.calls.map((t, l) => {
        const { abi: n, args: r, functionName: i, to: m } = k[d].calls[l], e = t.error?.data ?? t.returnData, O = BigInt(t.gasUsed), h = t.logs?.map((s) => z(s)), u = t.status === "0x1" ? "success" : "failure", T = n && u === "success" && e !== "0x" ? B({
          abi: n,
          data: e,
          functionName: i
        }) : null, E = (() => {
          if (u === "success")
            return;
          let s;
          if (t.error?.data === "0x" ? s = new D() : t.error && (s = new S(t.error)), !!s)
            return U(s, {
              abi: n ?? [],
              address: m ?? "0x",
              args: r,
              functionName: i ?? "<unknown>"
            });
        })();
        return {
          data: e,
          gasUsed: O,
          logs: h,
          status: u,
          ...u === "success" ? {
            result: T
          } : {
            error: E
          }
        };
      })
    }));
  } catch (a) {
    const f = a, c = A(f, {});
    throw c instanceof y ? f : c;
  }
}
export {
  nr as simulateBlocks
};
