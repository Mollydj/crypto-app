import { execTyped as $, bytesRegex as w, integerRegex as S, isTupleRegex as v } from "./index226.js";
import { UnknownSolidityTypeError as E } from "./index232.js";
import { InvalidParameterError as P, SolidityProtectedKeywordError as M, InvalidModifierError as R, InvalidFunctionModifierError as k } from "./index233.js";
import { UnknownSignatureError as z, InvalidSignatureError as p } from "./index234.js";
import { InvalidParenthesisError as A } from "./index235.js";
import { getParameterCacheKey as F, parameterCache as y } from "./index274.js";
import { isFunctionSignature as T, isEventSignature as _, isErrorSignature as C, isConstructorSignature as I, isFallbackSignature as Z, isReceiveSignature as K, functionModifiers as d, execFunctionSignature as L, execEventSignature as U, eventModifiers as W, execErrorSignature as D, execConstructorSignature as V, execFallbackSignature as j } from "./index228.js";
function ue(e, t = {}) {
  if (T(e))
    return q(e, t);
  if (_(e))
    return B(e, t);
  if (C(e))
    return G(e, t);
  if (I(e))
    return H(e, t);
  if (Z(e))
    return J(e);
  if (K(e))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new z({ signature: e });
}
function q(e, t = {}) {
  const n = L(e);
  if (!n)
    throw new p({ signature: e, type: "function" });
  const i = c(n.parameters), r = [], s = i.length;
  for (let a = 0; a < s; a++)
    r.push(l(i[a], {
      modifiers: d,
      structs: t,
      type: "function"
    }));
  const o = [];
  if (n.returns) {
    const a = c(n.returns), u = a.length;
    for (let f = 0; f < u; f++)
      o.push(l(a[f], {
        modifiers: d,
        structs: t,
        type: "function"
      }));
  }
  return {
    name: n.name,
    type: "function",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: r,
    outputs: o
  };
}
function B(e, t = {}) {
  const n = U(e);
  if (!n)
    throw new p({ signature: e, type: "event" });
  const i = c(n.parameters), r = [], s = i.length;
  for (let o = 0; o < s; o++)
    r.push(l(i[o], {
      modifiers: W,
      structs: t,
      type: "event"
    }));
  return { name: n.name, type: "event", inputs: r };
}
function G(e, t = {}) {
  const n = D(e);
  if (!n)
    throw new p({ signature: e, type: "error" });
  const i = c(n.parameters), r = [], s = i.length;
  for (let o = 0; o < s; o++)
    r.push(l(i[o], { structs: t, type: "error" }));
  return { name: n.name, type: "error", inputs: r };
}
function H(e, t = {}) {
  const n = V(e);
  if (!n)
    throw new p({ signature: e, type: "constructor" });
  const i = c(n.parameters), r = [], s = i.length;
  for (let o = 0; o < s; o++)
    r.push(l(i[o], { structs: t, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: r
  };
}
function J(e) {
  const t = j(e);
  if (!t)
    throw new p({ signature: e, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: t.stateMutability ?? "nonpayable"
  };
}
const N = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, O = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, Q = /^u?int$/;
function l(e, t) {
  const n = F(e, t?.type, t?.structs);
  if (y.has(n))
    return y.get(n);
  const i = v.test(e), r = $(i ? O : N, e);
  if (!r)
    throw new P({ param: e });
  if (r.name && ee(r.name))
    throw new M({ param: e, name: r.name });
  const s = r.name ? { name: r.name } : {}, o = r.modifier === "indexed" ? { indexed: !0 } : {}, a = t?.structs ?? {};
  let u, f = {};
  if (i) {
    u = "tuple";
    const g = c(r.type), b = [], x = g.length;
    for (let m = 0; m < x; m++)
      b.push(l(g[m], { structs: a }));
    f = { components: b };
  } else if (r.type in a)
    u = "tuple", f = { components: a[r.type] };
  else if (Q.test(r.type))
    u = `${r.type}256`;
  else if (u = r.type, t?.type !== "struct" && !X(u))
    throw new E({ type: u });
  if (r.modifier) {
    if (!t?.modifiers?.has?.(r.modifier))
      throw new R({
        param: e,
        type: t?.type,
        modifier: r.modifier
      });
    if (d.has(r.modifier) && !te(u, !!r.array))
      throw new k({
        param: e,
        type: t?.type,
        modifier: r.modifier
      });
  }
  const h = {
    type: `${u}${r.array ?? ""}`,
    ...s,
    ...o,
    ...f
  };
  return y.set(n, h), h;
}
function c(e, t = [], n = "", i = 0) {
  const r = e.trim().length;
  for (let s = 0; s < r; s++) {
    const o = e[s], a = e.slice(s + 1);
    switch (o) {
      case ",":
        return i === 0 ? c(a, [...t, n.trim()]) : c(a, t, `${n}${o}`, i);
      case "(":
        return c(a, t, `${n}${o}`, i + 1);
      case ")":
        return c(a, t, `${n}${o}`, i - 1);
      default:
        return c(a, t, `${n}${o}`, i);
    }
  }
  if (n === "")
    return t;
  if (i !== 0)
    throw new A({ current: n, depth: i });
  return t.push(n.trim()), t;
}
function X(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || w.test(e) || S.test(e);
}
const Y = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function ee(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || e === "tuple" || w.test(e) || S.test(e) || Y.test(e);
}
function te(e, t) {
  return t || e === "bytes" || e === "string" || e === "tuple";
}
export {
  ee as isSolidityKeyword,
  X as isSolidityType,
  te as isValidDataLocation,
  l as parseAbiParameter,
  H as parseConstructorSignature,
  G as parseErrorSignature,
  B as parseEventSignature,
  J as parseFallbackSignature,
  q as parseFunctionSignature,
  ue as parseSignature,
  c as splitParameters
};
