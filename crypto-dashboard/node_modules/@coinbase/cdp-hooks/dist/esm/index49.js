import { toRpc as $ } from "./index246.js";
import { parseAccount as W } from "./index36.js";
import { multicall3Abi as O } from "./index97.js";
import { aggregate3Signature as I } from "./index247.js";
import { deploylessCallViaBytecodeBytecode as J, deploylessCallViaFactoryBytecode as K } from "./index99.js";
import { BaseError as N } from "./index107.js";
import { ClientChainNotConfiguredError as P, ChainDoesNotSupportContract as Q } from "./index122.js";
import { CounterfactualDeploymentFailedError as U, RawContractError as X } from "./index110.js";
import { decodeFunctionResult as Y } from "./index155.js";
import { encodeDeployData as T } from "./index159.js";
import { encodeFunctionData as Z } from "./index162.js";
import { getChainContractAddress as tt } from "./index198.js";
import { numberToHex as V } from "./index134.js";
import { getCallError as at } from "./index248.js";
import { extract as et } from "./index249.js";
import { formatTransactionRequest as rt } from "./index169.js";
import { createBatchScheduler as ot } from "./index40.js";
import { serializeStateOverride as ct } from "./index250.js";
import { assertRequest as nt } from "./index182.js";
import { parseAbi as z } from "./index227.js";
async function Et(t, a) {
  const { account: e = t.account, authorizationList: n, batch: r = !!t.batch?.multicall, blockNumber: m, blockTag: C = t.experimental_blockTag ?? "latest", accessList: x, blobs: D, blockOverrides: d, code: p, data: o, factory: u, factoryData: s, gas: B, gasPrice: b, maxFeePerBlobGas: h, maxFeePerGas: y, maxPriorityFeePerGas: g, nonce: k, to: f, value: H, stateOverride: L, ...j } = a, R = e ? W(e) : void 0;
  if (p && (u || s))
    throw new N("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (p && f)
    throw new N("Cannot provide both `code` & `to` as parameters.");
  const S = p && o, _ = u && s && f && o, A = S || _, G = S ? lt({
    code: p,
    data: o
  }) : _ ? dt({
    data: o,
    factory: u,
    factoryData: s,
    to: f
  }) : o;
  try {
    nt(a);
    const w = (typeof m == "bigint" ? V(m) : void 0) || C, i = d ? $(d) : void 0, l = ct(L), q = t.chain?.formatters?.transactionRequest?.format, v = (q || rt)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...et(j, { format: q }),
      from: R?.address,
      accessList: x,
      authorizationList: n,
      blobs: D,
      data: G,
      gas: B,
      gasPrice: b,
      maxFeePerBlobGas: h,
      maxFeePerGas: y,
      maxPriorityFeePerGas: g,
      nonce: k,
      to: A ? void 0 : f,
      value: H
    });
    if (r && st({ request: v }) && !l && !i)
      try {
        return await it(t, {
          ...v,
          blockNumber: m,
          blockTag: C
        });
      } catch (c) {
        if (!(c instanceof P) && !(c instanceof Q))
          throw c;
      }
    const M = (() => {
      const c = [
        v,
        w
      ];
      return l && i ? [...c, l, i] : l ? [...c, l] : i ? [...c, {}, i] : c;
    })(), E = await t.request({
      method: "eth_call",
      params: M
    });
    return E === "0x" ? { data: void 0 } : { data: E };
  } catch (F) {
    const w = ut(F), { offchainLookup: i, offchainLookupSignature: l } = await import("./index186.js");
    if (t.ccipRead !== !1 && w?.slice(0, 10) === l && f)
      return { data: await i(t, { data: w, to: f }) };
    throw A && w?.slice(0, 10) === "0x101bb98d" ? new U({ factory: u }) : at(F, {
      ...a,
      account: R,
      chain: t.chain
    });
  }
}
function st({ request: t }) {
  const { data: a, to: e, ...n } = t;
  return !(!a || a.startsWith(I) || !e || Object.values(n).filter((r) => typeof r < "u").length > 0);
}
async function it(t, a) {
  const { batchSize: e = 1024, wait: n = 0 } = typeof t.batch?.multicall == "object" ? t.batch.multicall : {}, { blockNumber: r, blockTag: m = t.experimental_blockTag ?? "latest", data: C, multicallAddress: x, to: D } = a;
  let d = x;
  if (!d) {
    if (!t.chain)
      throw new P();
    d = tt({
      blockNumber: r,
      chain: t.chain,
      contract: "multicall3"
    });
  }
  const o = (typeof r == "bigint" ? V(r) : void 0) || m, { schedule: u } = ot({
    id: `${t.uid}.${o}`,
    wait: n,
    shouldSplitBatch(b) {
      return b.reduce((y, { data: g }) => y + (g.length - 2), 0) > e * 2;
    },
    fn: async (b) => {
      const h = b.map((k) => ({
        allowFailure: !0,
        callData: k.data,
        target: k.to
      })), y = Z({
        abi: O,
        args: [h],
        functionName: "aggregate3"
      }), g = await t.request({
        method: "eth_call",
        params: [
          {
            data: y,
            to: d
          },
          o
        ]
      });
      return Y({
        abi: O,
        args: [h],
        functionName: "aggregate3",
        data: g || "0x"
      });
    }
  }), [{ returnData: s, success: B }] = await u({ data: C, to: D });
  if (!B)
    throw new X({ data: s });
  return s === "0x" ? { data: void 0 } : { data: s };
}
function lt(t) {
  const { code: a, data: e } = t;
  return T({
    abi: z(["constructor(bytes, bytes)"]),
    bytecode: J,
    args: [a, e]
  });
}
function dt(t) {
  const { data: a, factory: e, factoryData: n, to: r } = t;
  return T({
    abi: z(["constructor(address, bytes, address, bytes)"]),
    bytecode: K,
    args: [r, a, e, n]
  });
}
function ut(t) {
  if (!(t instanceof N))
    return;
  const a = t.walk();
  return typeof a?.data == "object" ? a.data?.data : a.data;
}
export {
  Et as call,
  ut as getRevertErrorData
};
