import { maxBytesPerTransaction as y, fieldElementsPerBlob as a, bytesPerFieldElement as f, bytesPerBlob as p } from "./index196.js";
import { EmptyBlobError as c, BlobSizeTooLargeError as h } from "./index185.js";
import { createCursor as B } from "./index145.js";
import { size as u } from "./index106.js";
import { hexToBytes as x } from "./index133.js";
import { bytesToHex as d } from "./index134.js";
function S(e) {
  const m = e.to ?? (typeof e.data == "string" ? "hex" : "bytes"), i = typeof e.data == "string" ? x(e.data) : e.data, o = u(i);
  if (!o)
    throw new c();
  if (o > y)
    throw new h({
      maxSize: y,
      size: o
    });
  const s = [];
  let n = !0, r = 0;
  for (; n; ) {
    const t = B(new Uint8Array(p));
    let l = 0;
    for (; l < a; ) {
      const b = i.slice(r, r + (f - 1));
      if (t.pushByte(0), t.pushBytes(b), b.length < 31) {
        t.pushByte(128), n = !1;
        break;
      }
      l++, r += 31;
    }
    s.push(t);
  }
  return m === "bytes" ? s.map((t) => t.bytes) : s.map((t) => d(t.bytes));
}
export {
  S as toBlobs
};
