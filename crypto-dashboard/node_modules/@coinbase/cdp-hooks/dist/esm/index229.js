import { isTupleRegex as g, execTyped as w } from "./index226.js";
import { UnknownTypeError as S } from "./index232.js";
import { InvalidAbiTypeParameterError as d } from "./index233.js";
import { InvalidSignatureError as T, InvalidStructSignatureError as v } from "./index234.js";
import { CircularReferenceError as x } from "./index236.js";
import { isStructSignature as E, execStructSignature as b } from "./index228.js";
import { parseAbiParameter as A, isSolidityType as $ } from "./index230.js";
function C(s) {
  const n = {}, c = s.length;
  for (let t = 0; t < c; t++) {
    const i = s[t];
    if (!E(i))
      continue;
    const r = b(i);
    if (!r)
      throw new T({ signature: i, type: "struct" });
    const u = r.properties.split(";"), e = [], h = u.length;
    for (let l = 0; l < h; l++) {
      const m = u[l].trim();
      if (!m)
        continue;
      const y = A(m, {
        type: "struct"
      });
      e.push(y);
    }
    if (!e.length)
      throw new v({ signature: i });
    n[r.name] = e;
  }
  const o = {}, a = Object.entries(n), p = a.length;
  for (let t = 0; t < p; t++) {
    const [i, r] = a[t];
    o[i] = f(r, n);
  }
  return o;
}
const I = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function f(s, n, c = /* @__PURE__ */ new Set()) {
  const o = [], a = s.length;
  for (let p = 0; p < a; p++) {
    const t = s[p];
    if (g.test(t.type))
      o.push(t);
    else {
      const r = w(I, t.type);
      if (!r?.type)
        throw new d({ abiParameter: t });
      const { array: u, type: e } = r;
      if (e in n) {
        if (c.has(e))
          throw new x({ type: e });
        o.push({
          ...t,
          type: `tuple${u ?? ""}`,
          components: f(n[e] ?? [], n, /* @__PURE__ */ new Set([...c, e]))
        });
      } else if ($(e))
        o.push(t);
      else
        throw new S({ type: e });
    }
  }
  return o;
}
export {
  C as parseStructs
};
