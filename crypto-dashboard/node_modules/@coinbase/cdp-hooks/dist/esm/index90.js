import { DecodeLogDataMismatch as M, DecodeLogTopicsMismatch as P } from "./index104.js";
import { InvalidInputRpcError as T } from "./index121.js";
import { decodeEventLog as z } from "./index151.js";
import { encodeEventTopics as A } from "./index161.js";
import { formatLog as B } from "./index142.js";
import { getAction as g } from "./index237.js";
import { observe as F } from "./index239.js";
import { poll as O } from "./index240.js";
import { stringify as D } from "./index128.js";
import { createContractEventFilter as R } from "./index52.js";
import { getBlockNumber as U } from "./index62.js";
import { getContractEvents as j } from "./index66.js";
import { getFilterChanges as q } from "./index69.js";
import { uninstallFilter as x } from "./index84.js";
function st(t, S) {
  const { abi: b, address: p, args: l, batch: E = !0, eventName: c, fromBlock: m, onError: h, onLogs: N, poll: L, pollingInterval: w = t.pollingInterval, strict: v } = S;
  return (typeof L < "u" ? L : typeof m == "bigint" ? !0 : !(t.transport.type === "webSocket" || t.transport.type === "ipc" || t.transport.type === "fallback" && (t.transport.transports[0].config.type === "webSocket" || t.transport.transports[0].config.type === "ipc"))) ? (() => {
    const u = v ?? !1, C = D([
      "watchContractEvent",
      p,
      l,
      E,
      t.uid,
      c,
      w,
      u,
      m
    ]);
    return F(C, { onLogs: N, onError: h }, (a) => {
      let n;
      m !== void 0 && (n = m - 1n);
      let e, s = !1;
      const k = O(async () => {
        if (!s) {
          try {
            e = await g(t, R, "createContractEventFilter")({
              abi: b,
              address: p,
              args: l,
              eventName: c,
              strict: u,
              fromBlock: m
            });
          } catch {
          }
          s = !0;
          return;
        }
        try {
          let o;
          if (e)
            o = await g(t, q, "getFilterChanges")({ filter: e });
          else {
            const r = await g(t, U, "getBlockNumber")({});
            n && n < r ? o = await g(t, j, "getContractEvents")({
              abi: b,
              address: p,
              args: l,
              eventName: c,
              fromBlock: n + 1n,
              toBlock: r,
              strict: u
            }) : o = [], n = r;
          }
          if (o.length === 0)
            return;
          if (E)
            a.onLogs(o);
          else
            for (const r of o)
              a.onLogs([r]);
        } catch (o) {
          e && o instanceof T && (s = !1), a.onError?.(o);
        }
      }, {
        emitOnBegin: !0,
        interval: w
      });
      return async () => {
        e && await g(t, x, "uninstallFilter")({ filter: e }), k();
      };
    });
  })() : (() => {
    const u = v ?? !1, C = D([
      "watchContractEvent",
      p,
      l,
      E,
      t.uid,
      c,
      w,
      u
    ]);
    let a = !0, n = () => a = !1;
    return F(C, { onLogs: N, onError: h }, (e) => ((async () => {
      try {
        const s = (() => {
          if (t.transport.type === "fallback") {
            const r = t.transport.transports.find((i) => i.config.type === "webSocket" || i.config.type === "ipc");
            return r ? r.value : t.transport;
          }
          return t.transport;
        })(), k = c ? A({
          abi: b,
          eventName: c,
          args: l
        }) : [], { unsubscribe: o } = await s.subscribe({
          params: ["logs", { address: p, topics: k }],
          onData(r) {
            if (!a)
              return;
            const i = r.result;
            try {
              const { eventName: f, args: d } = z({
                abi: b,
                data: i.data,
                topics: i.topics,
                strict: v
              }), y = B(i, {
                args: d,
                eventName: f
              });
              e.onLogs([y]);
            } catch (f) {
              let d, y;
              if (f instanceof M || f instanceof P) {
                if (v)
                  return;
                d = f.abiItem.name, y = f.abiItem.inputs?.some((I) => !("name" in I && I.name));
              }
              const _ = B(i, {
                args: y ? [] : {},
                eventName: d
              });
              e.onLogs([_]);
            }
          },
          onError(r) {
            e.onError?.(r);
          }
        });
        n = o, a || n();
      } catch (s) {
        h?.(s);
      }
    })(), () => n()));
  })();
}
export {
  st as watchContractEvent
};
