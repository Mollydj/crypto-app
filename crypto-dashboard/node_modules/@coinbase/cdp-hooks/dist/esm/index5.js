import { verifyEmailOTP as T, verifySmsOTP as O, authenticateWithJWT as U, signInWithOAuth as y, getAccessToken as I, sendUserOperation as W, signInWithEmail as b, signInWithSms as x, signOut as k, signEvmHash as C, signEvmTransaction as M, sendEvmTransaction as j, signEvmMessage as H, signSolanaMessage as P, signEvmTypedData as D, exportEvmAccount as F, exportSolanaAccount as z, signSolanaTransaction as J, sendSolanaTransaction as V, getUserOperation as G } from "@coinbase/cdp-core";
import "./index2.js";
import { useSendHookCallOnce as e } from "./index25.js";
import { useState as d, useEffect as E, useMemo as q, useCallback as w } from "react";
import { useCDP as p } from "./index4.js";
import { useAutoPolling as B } from "./index26.js";
import { getPublicClient as K } from "./index27.js";
const en = () => {
  e("use_config");
  const { config: n } = p();
  return { config: n };
}, sn = () => {
  e("use_is_initialized");
  const { isInitialized: n } = p();
  return { isInitialized: n };
}, tn = () => (e("use_sign_in_with_email"), { signInWithEmail: f(b) }), rn = () => (e("use_sign_in_with_sms"), { signInWithSms: f(x) }), an = () => (e("use_verify_email_otp"), { verifyEmailOTP: T }), on = () => (e("use_verify_sms_otp"), { verifySmsOTP: O }), cn = () => (e("use_authenticate_with_jwt"), { authenticateWithJWT: U }), un = () => {
  e("use_sign_in_with_oauth");
  const { oauthState: n } = L();
  return { signInWithOAuth: y, oauthState: n };
}, L = () => {
  e("use_oauth_state");
  const { oauthState: n } = p();
  return { oauthState: n };
}, pn = () => {
  e("use_is_signed_in");
  const { isSignedIn: n } = p();
  return { isSignedIn: n };
}, g = () => {
  e("use_current_user");
  const { currentUser: n } = p();
  return { currentUser: n };
}, dn = () => (e("use_sign_out"), { signOut: i(k) }), ln = () => (e("use_get_access_token"), { getAccessToken: I }), mn = () => {
  e("use_evm_address");
  const { currentUser: n } = g();
  return {
    evmAddress: n?.evmSmartAccountObjects?.[0]?.address ?? n?.evmAccountObjects?.[0]?.address ?? null
  };
}, gn = () => {
  e("use_solana_address");
  const { currentUser: n } = g();
  return {
    solanaAddress: n?.solanaAccountObjects?.[0]?.address ?? null
  };
}, _n = () => {
  e("use_evm_account_objects");
  const { currentUser: n } = g();
  return {
    evmAccounts: n?.evmAccountObjects ?? null
  };
}, Sn = () => {
  e("use_solana_account_objects");
  const { currentUser: n } = g();
  return {
    solanaAccounts: n?.solanaAccountObjects ?? null
  };
}, vn = () => {
  e("use_evm_smart_account_objects");
  const { currentUser: n } = g();
  return {
    evmSmartAccounts: n?.evmSmartAccountObjects ?? null
  };
}, hn = () => (e("use_sign_evm_hash"), { signEvmHash: i(C) }), En = () => (e("use_sign_evm_transaction"), { signEvmTransaction: i(M) }), wn = () => {
  e("use_send_evm_transaction");
  const [n, s] = d(null), [a, r] = d(null), [u, _] = d(null), { config: o } = p(), l = i(
    async (S) => {
      const c = await j(S);
      return s({ hash: c.transactionHash, network: S.network }), _(null), r(null), c;
    }
  );
  E(() => {
    if (!n) return;
    (async () => {
      try {
        const v = await K(n.network, o).waitForTransactionReceipt({
          hash: n.hash
        });
        r(v);
      } catch (c) {
        _(c instanceof Error ? c : new Error(String(c)));
      }
    })();
  }, [n]);
  const m = q(() => n ? a ? { status: "success", receipt: a } : u ? { status: "error", error: u } : { status: "pending", hash: n.hash } : { status: "idle" }, [n, a, u]);
  return {
    sendEvmTransaction: l,
    data: m
  };
}, fn = () => (e("use_sign_evm_message"), { signEvmMessage: i(H) }), An = () => (e("use_sign_solana_message"), { signSolanaMessage: i(P) }), Tn = () => (e("use_sign_evm_typed_data"), { signEvmTypedData: i(D) }), On = () => (e("use_export_evm_account"), { exportEvmAccount: i(F) }), Un = () => (e("use_export_solana_account"), { exportSolanaAccount: i(z) }), yn = () => (e("use_sign_solana_transaction"), { signSolanaTransaction: i(J) }), In = () => (e("use_send_solana_transaction"), {
  sendSolanaTransaction: i(V)
}), i = (n) => {
  const { isSignedIn: s } = p();
  return w(
    async (...r) => {
      if (!s)
        throw new Error("User is not authenticated");
      return n(...r);
    },
    [s, n]
  );
}, f = (n) => {
  const { isSignedIn: s } = p();
  return w(
    async (...r) => {
      if (s)
        throw new Error("User is already authenticated. Please sign out first.");
      return n(...r);
    },
    [s, n]
  );
}, Wn = () => {
  e("use_send_user_operation");
  const [n, s] = d(void 0), { status: a, data: r, error: u } = N(n);
  return {
    sendUserOperation: i(
      async (o) => {
        const l = await W(o);
        return s({
          userOperationHash: l.userOperationHash,
          evmSmartAccount: o.evmSmartAccount,
          network: o.network
        }), l;
      }
    ),
    data: r,
    error: u,
    status: a
  };
}, N = (n = {}) => {
  e("use_wait_for_user_operation");
  const { userOperationHash: s, evmSmartAccount: a, network: r, enabled: u } = n, [_, o] = d("idle"), [l, m] = d(void 0), [S, c] = d(void 0), { currentUser: v } = g();
  E(() => {
    s && a && r && (o(u !== !1 ? "pending" : "idle"), m(void 0), c(void 0));
  }, [s, a, r, u]);
  const h = u !== !1 && !!(s && a && r && v);
  return B(
    {
      pollFn: async () => {
        const t = await G({
          userOperationHash: s,
          evmSmartAccount: a,
          network: r
        });
        return m(t), t;
      },
      shouldStop: (t) => t.status === "complete" || t.status === "dropped" || t.status === "failed",
      enabled: h,
      onSuccess: (t) => {
        if (t.status === "complete")
          m(t), o("success");
        else if (t.status === "failed") {
          const A = t.receipts?.[0]?.revert?.message || "User operation failed";
          c(new Error(A)), o("error");
        } else t.status === "dropped" ? (c(new Error('User operation failed with status: "dropped"')), o("error")) : (m(t), o("error"));
      },
      onError: (t) => {
        c(t), o("error");
      }
    },
    [s, a, r, h]
  ), {
    status: _,
    data: l,
    error: S
  };
};
export {
  cn as useAuthenticateWithJWT,
  en as useConfig,
  g as useCurrentUser,
  i as useEnforceAuthenticated,
  f as useEnforceUnauthenticated,
  _n as useEvmAccounts,
  mn as useEvmAddress,
  vn as useEvmSmartAccounts,
  On as useExportEvmAccount,
  Un as useExportSolanaAccount,
  ln as useGetAccessToken,
  sn as useIsInitialized,
  pn as useIsSignedIn,
  L as useOAuthState,
  wn as useSendEvmTransaction,
  In as useSendSolanaTransaction,
  Wn as useSendUserOperation,
  hn as useSignEvmHash,
  fn as useSignEvmMessage,
  En as useSignEvmTransaction,
  Tn as useSignEvmTypedData,
  tn as useSignInWithEmail,
  un as useSignInWithOAuth,
  rn as useSignInWithSms,
  dn as useSignOut,
  An as useSignSolanaMessage,
  yn as useSignSolanaTransaction,
  Sn as useSolanaAccounts,
  gn as useSolanaAddress,
  an as useVerifyEmailOTP,
  on as useVerifySmsOTP,
  N as useWaitForUserOperation
};
