import { encode as J, from as K } from "./index257.js";
import { encodeData as M, from as o } from "./index258.js";
import { parseAccount as Q } from "./index36.js";
import { zeroAddress as t, ethAddress as S } from "./index98.js";
import { deploylessCallViaBytecodeBytecode as W } from "./index99.js";
import { BaseError as X } from "./index107.js";
import { encodeFunctionData as Y } from "./index162.js";
import { createAccessList as Z } from "./index50.js";
import { simulateBlocks as ss } from "./index81.js";
import { hexToBigInt as k } from "./index167.js";
const es = "0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";
async function bs(b, r) {
  const { blockNumber: g, blockTag: y, calls: h, stateOverrides: u, traceAssetChanges: a, traceTransfers: P, validation: _ } = r, f = r.account ? Q(r.account) : void 0;
  if (a && !f)
    throw new X("`account` is required when `traceAssetChanges` is true");
  const m = f ? J(K("constructor(bytes, bytes)"), {
    bytecode: W,
    args: [
      es,
      M(o("function getBalance(address)"), [f.address])
    ]
  }) : void 0, n = a ? await Promise.all(r.calls.map(async (s) => {
    if (!s.data && !s.abi)
      return;
    const { accessList: e } = await Z(b, {
      account: f.address,
      ...s,
      data: s.abi ? Y(s) : s.data
    });
    return e.map(({ address: c, storageKeys: d }) => d.length > 0 ? c : null);
  })).then((s) => s.flat().filter(Boolean)) : [], l = await ss(b, {
    blockNumber: g,
    blockTag: y,
    blocks: [
      ...a ? [
        // ETH pre balances
        {
          calls: [{ data: m }],
          stateOverrides: u
        },
        // Asset pre balances
        {
          calls: n.map((s, e) => ({
            abi: [
              o("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [f.address],
            to: s,
            from: t,
            nonce: e
          })),
          stateOverrides: [
            {
              address: t,
              nonce: 0
            }
          ]
        }
      ] : [],
      {
        calls: [...h, {}].map((s) => ({
          ...s,
          from: f?.address
        })),
        stateOverrides: u
      },
      ...a ? [
        // ETH post balances
        {
          calls: [{ data: m }]
        },
        // Asset post balances
        {
          calls: n.map((s, e) => ({
            abi: [
              o("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [f.address],
            to: s,
            from: t,
            nonce: e
          })),
          stateOverrides: [
            {
              address: t,
              nonce: 0
            }
          ]
        },
        // Decimals
        {
          calls: n.map((s, e) => ({
            to: s,
            abi: [
              o("function decimals() returns (uint256)")
            ],
            functionName: "decimals",
            from: t,
            nonce: e
          })),
          stateOverrides: [
            {
              address: t,
              nonce: 0
            }
          ]
        },
        // Token URI
        {
          calls: n.map((s, e) => ({
            to: s,
            abi: [
              o("function tokenURI(uint256) returns (string)")
            ],
            functionName: "tokenURI",
            args: [0n],
            from: t,
            nonce: e
          })),
          stateOverrides: [
            {
              address: t,
              nonce: 0
            }
          ]
        },
        // Symbols
        {
          calls: n.map((s, e) => ({
            to: s,
            abi: [o("function symbol() returns (string)")],
            functionName: "symbol",
            from: t,
            nonce: e
          })),
          stateOverrides: [
            {
              address: t,
              nonce: 0
            }
          ]
        }
      ] : []
    ],
    traceTransfers: P,
    validation: _
  }), O = a ? l[2] : l[0], [B, v, , A, N, w, C, I] = a ? l : [], { calls: R, ...T } = O, U = R.slice(0, -1) ?? [], D = B?.calls ?? [], E = v?.calls ?? [], L = [...D, ...E].map((s) => s.status === "success" ? k(s.data) : null), q = A?.calls ?? [], z = N?.calls ?? [], F = [...q, ...z].map((s) => s.status === "success" ? k(s.data) : null), H = (w?.calls ?? []).map((s) => s.status === "success" ? s.result : null), V = (I?.calls ?? []).map((s) => s.status === "success" ? s.result : null), $ = (C?.calls ?? []).map((s) => s.status === "success" ? s.result : null), i = [];
  for (const [s, e] of F.entries()) {
    const c = L[s];
    if (typeof e != "bigint" || typeof c != "bigint")
      continue;
    const d = H[s - 1], j = V[s - 1], x = $[s - 1], p = s === 0 ? {
      address: S,
      decimals: 18,
      symbol: "ETH"
    } : {
      address: n[s - 1],
      decimals: x || d ? Number(d ?? 1) : void 0,
      symbol: j ?? void 0
    };
    i.some((G) => G.token.address === p.address) || i.push({
      token: p,
      value: {
        pre: c,
        post: e,
        diff: e - c
      }
    });
  }
  return {
    assetChanges: i,
    block: T,
    results: U
  };
}
export {
  bs as simulateCalls
};
