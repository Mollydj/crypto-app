import { call as h } from "./index49.js";
import { OffchainLookupSenderMismatchError as w, OffchainLookupError as b, OffchainLookupResponseMalformedError as k } from "./index187.js";
import { HttpRequestError as m } from "./index38.js";
import { decodeErrorResult as g } from "./index112.js";
import { encodeAbiParameters as q } from "./index149.js";
import { isAddressEqual as E } from "./index166.js";
import { concat as L } from "./index138.js";
import { isHex as O } from "./index170.js";
import { localBatchGatewayUrl as R, localBatchGatewayRequest as x } from "./index188.js";
import { stringify as S } from "./index128.js";
const I = "0x556f1830", T = {
  name: "OffchainLookup",
  type: "error",
  inputs: [
    {
      name: "sender",
      type: "address"
    },
    {
      name: "urls",
      type: "string[]"
    },
    {
      name: "callData",
      type: "bytes"
    },
    {
      name: "callbackFunction",
      type: "bytes4"
    },
    {
      name: "extraData",
      type: "bytes"
    }
  ]
};
async function J(c, { blockNumber: i, blockTag: p, data: a, to: o }) {
  const { args: n } = g({
    data: a,
    abi: [T]
  }), [r, s, f, e, t] = n, { ccipRead: u } = c, d = u && typeof u?.request == "function" ? u.request : A;
  try {
    if (!E(o, r))
      throw new w({ sender: r, to: o });
    const l = s.includes(R) ? await x({
      data: f,
      ccipRequest: d
    }) : await d({ data: f, sender: r, urls: s }), { data: y } = await h(c, {
      blockNumber: i,
      blockTag: p,
      data: L([
        e,
        q([{ type: "bytes" }, { type: "bytes" }], [l, t])
      ]),
      to: o
    });
    return y;
  } catch (l) {
    throw new b({
      callbackSelector: e,
      cause: l,
      data: a,
      extraData: t,
      sender: r,
      urls: s
    });
  }
}
async function A({ data: c, sender: i, urls: p }) {
  let a = new Error("An unknown error occurred.");
  for (let o = 0; o < p.length; o++) {
    const n = p[o], r = n.includes("{data}") ? "GET" : "POST", s = r === "POST" ? { data: c, sender: i } : void 0, f = r === "POST" ? { "Content-Type": "application/json" } : {};
    try {
      const e = await fetch(n.replace("{sender}", i.toLowerCase()).replace("{data}", c), {
        body: JSON.stringify(s),
        headers: f,
        method: r
      });
      let t;
      if (e.headers.get("Content-Type")?.startsWith("application/json") ? t = (await e.json()).data : t = await e.text(), !e.ok) {
        a = new m({
          body: s,
          details: t?.error ? S(t.error) : e.statusText,
          headers: e.headers,
          status: e.status,
          url: n
        });
        continue;
      }
      if (!O(t)) {
        a = new k({
          result: t,
          url: n
        });
        continue;
      }
      return t;
    } catch (e) {
      a = new m({
        body: s,
        details: e.message,
        url: n
      });
    }
  }
  throw a;
}
export {
  A as ccipRequest,
  J as offchainLookup,
  T as offchainLookupAbiItem,
  I as offchainLookupSignature
};
