import { textResolverAbi as l, universalResolverResolveAbi as h } from "./index97.js";
import { decodeFunctionResult as p } from "./index155.js";
import { encodeFunctionData as A } from "./index162.js";
import { getChainContractAddress as R } from "./index198.js";
import { toHex as b } from "./index134.js";
import { isNullUniversalResolverError as g } from "./index243.js";
import { localBatchGatewayUrl as w } from "./index188.js";
import { namehash as x } from "./index137.js";
import { packetToBytes as C } from "./index244.js";
import { getAction as y } from "./index237.js";
import { readContract as N } from "./index80.js";
async function j(n, e) {
  const { blockNumber: s, blockTag: m, key: d, name: t, gatewayUrls: u, strict: f } = e, { chain: o } = n, v = (() => {
    if (e.universalResolverAddress)
      return e.universalResolverAddress;
    if (!o)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return R({
      blockNumber: s,
      chain: o,
      contract: "ensUniversalResolver"
    });
  })(), a = o?.ensTlds;
  if (a && !a.some((r) => t.endsWith(r)))
    return null;
  try {
    const r = {
      address: v,
      abi: h,
      functionName: "resolve",
      args: [
        b(C(t)),
        A({
          abi: l,
          functionName: "text",
          args: [x(t), d]
        }),
        u ?? [w]
      ],
      blockNumber: s,
      blockTag: m
    }, i = await y(n, N, "readContract")(r);
    if (i[0] === "0x")
      return null;
    const c = p({
      abi: l,
      functionName: "text",
      data: i[0]
    });
    return c === "" ? null : c;
  } catch (r) {
    if (f)
      throw r;
    if (g(r, "resolve"))
      return null;
    throw r;
  }
}
export {
  j as getEnsText
};
