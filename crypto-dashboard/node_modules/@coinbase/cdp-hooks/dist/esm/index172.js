import { encodeAbiParameters as p } from "./index149.js";
import { concat as h } from "./index138.js";
import { toHex as d } from "./index134.js";
import { keccak256 as i } from "./index135.js";
import { getTypesForEIP712Domain as T, validateTypedData as D } from "./index173.js";
function k(o) {
  const { domain: n = {}, message: e, primaryType: t } = o, r = {
    EIP712Domain: T({ domain: n }),
    ...o.types
  };
  D({
    domain: n,
    message: e,
    primaryType: t,
    types: r
  });
  const a = ["0x1901"];
  return n && a.push(b({
    domain: n,
    types: r
  })), t !== "EIP712Domain" && a.push(f({
    data: e,
    primaryType: t,
    types: r
  })), i(h(a));
}
function b({ domain: o, types: n }) {
  return f({
    data: o,
    primaryType: "EIP712Domain",
    types: n
  });
}
function f({ data: o, primaryType: n, types: e }) {
  const t = m({
    data: o,
    primaryType: n,
    types: e
  });
  return i(t);
}
function m({ data: o, primaryType: n, types: e }) {
  const t = [{ type: "bytes32" }], r = [l({ primaryType: n, types: e })];
  for (const a of e[n]) {
    const [c, s] = y({
      types: e,
      name: a.name,
      type: a.type,
      value: o[a.name]
    });
    t.push(c), r.push(s);
  }
  return p(t, r);
}
function l({ primaryType: o, types: n }) {
  const e = d(x({ primaryType: o, types: n }));
  return i(e);
}
function x({ primaryType: o, types: n }) {
  let e = "";
  const t = u({ primaryType: o, types: n });
  t.delete(o);
  const r = [o, ...Array.from(t).sort()];
  for (const a of r)
    e += `${a}(${n[a].map(({ name: c, type: s }) => `${s} ${c}`).join(",")})`;
  return e;
}
function u({ primaryType: o, types: n }, e = /* @__PURE__ */ new Set()) {
  const r = o.match(/^\w*/u)?.[0];
  if (e.has(r) || n[r] === void 0)
    return e;
  e.add(r);
  for (const a of n[r])
    u({ primaryType: a.type, types: n }, e);
  return e;
}
function y({ types: o, name: n, type: e, value: t }) {
  if (o[e] !== void 0)
    return [
      { type: "bytes32" },
      i(m({ data: t, primaryType: e, types: o }))
    ];
  if (e === "bytes")
    return t = `0x${(t.length % 2 ? "0" : "") + t.slice(2)}`, [{ type: "bytes32" }, i(t)];
  if (e === "string")
    return [{ type: "bytes32" }, i(d(t))];
  if (e.lastIndexOf("]") === e.length - 1) {
    const r = e.slice(0, e.lastIndexOf("[")), a = t.map((c) => y({
      name: n,
      type: r,
      types: o,
      value: c
    }));
    return [
      { type: "bytes32" },
      i(p(a.map(([c]) => c), a.map(([, c]) => c)))
    ];
  }
  return [{ type: e }, t];
}
export {
  x as encodeType,
  b as hashDomain,
  f as hashStruct,
  k as hashTypedData
};
