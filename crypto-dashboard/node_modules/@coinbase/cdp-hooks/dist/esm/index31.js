import { RpcRequestError as O } from "./index38.js";
import { UrlRequiredError as P } from "./index39.js";
import { createBatchScheduler as U } from "./index40.js";
import { getHttpRpcClient as _ } from "./index41.js";
import { createTransport as j } from "./index42.js";
function g(k, e = {}) {
  const { batch: o, fetchOptions: s, key: a = "http", methods: h, name: l = "HTTP JSON-RPC", onFetchRequest: m, onFetchResponse: f, retryDelay: y, raw: d } = e;
  return ({ chain: R, retryCount: w, timeout: q }) => {
    const { batchSize: C = 1e3, wait: S = 0 } = typeof o == "object" ? o : {}, b = e.retryCount ?? w, u = q ?? e.timeout ?? 1e4, r = R?.rpcUrls.default.http[0];
    if (!r)
      throw new P();
    const c = _(r, {
      fetchOptions: s,
      onRequest: m,
      onResponse: f,
      timeout: u
    });
    return j({
      key: a,
      methods: h,
      name: l,
      async request({ method: T, params: B }) {
        const i = { method: T, params: B }, { schedule: E } = U({
          id: r,
          wait: S,
          shouldSplitBatch(t) {
            return t.length > C;
          },
          fn: (t) => c.request({
            body: t
          }),
          sort: (t, H) => t.id - H.id
        }), F = async (t) => o ? E(t) : [
          await c.request({
            body: t
          })
        ], [{ error: n, result: p }] = await F(i);
        if (d)
          return { error: n, result: p };
        if (n)
          throw new O({
            body: i,
            error: n,
            url: r
          });
        return p;
      },
      retryCount: b,
      retryDelay: y,
      timeout: u,
      type: "http"
    }, {
      fetchOptions: s,
      url: r
    });
  };
}
export {
  g as http
};
