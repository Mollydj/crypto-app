import { hexToBytes as p, isBytes as B, abytes as v, bytesToHex as d, concatBytes as U } from "./index270.js";
import { anumber as W, randomBytes as C, utf8ToBytes as G } from "./index270.js";
const y = /* @__PURE__ */ BigInt(0), g = /* @__PURE__ */ BigInt(1);
function k(t, r) {
  if (typeof r != "boolean")
    throw new Error(t + " boolean expected, got " + r);
}
function j(t) {
  const r = t.toString(16);
  return r.length & 1 ? "0" + r : r;
}
function h(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? y : BigInt("0x" + t);
}
function H(t) {
  return h(d(t));
}
function O(t) {
  return v(t), h(d(Uint8Array.from(t).reverse()));
}
function x(t, r) {
  return p(t.toString(16).padStart(r * 2, "0"));
}
function S(t, r) {
  return x(t, r).reverse();
}
function _(t, r, n) {
  let o;
  if (typeof r == "string")
    try {
      o = p(r);
    } catch (e) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + e);
    }
  else if (B(r))
    o = Uint8Array.from(r);
  else
    throw new Error(t + " must be hex string or Uint8Array");
  const i = o.length;
  if (typeof n == "number" && i !== n)
    throw new Error(t + " of length " + n + " expected, got " + i);
  return o;
}
const w = (t) => typeof t == "bigint" && y <= t;
function T(t, r, n) {
  return w(t) && w(r) && w(n) && r <= t && t < n;
}
function $(t, r, n, o) {
  if (!T(r, n, o))
    throw new Error("expected valid " + t + ": " + n + " <= n < " + o + ", got " + r);
}
function M(t) {
  let r;
  for (r = 0; t > y; t >>= g, r += 1)
    ;
  return r;
}
const N = (t) => (g << BigInt(t)) - g;
function R(t, r, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof r != "number" || r < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  const o = (u) => new Uint8Array(u), i = (u) => Uint8Array.of(u);
  let e = o(t), s = o(t), f = 0;
  const c = () => {
    e.fill(1), s.fill(0), f = 0;
  }, l = (...u) => n(s, e, ...u), m = (u = o(0)) => {
    s = l(i(0), u), e = l(), u.length !== 0 && (s = l(i(1), u), e = l());
  }, E = () => {
    if (f++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let u = 0;
    const a = [];
    for (; u < r; ) {
      e = l();
      const b = e.slice();
      a.push(b), u += e.length;
    }
    return U(...a);
  };
  return (u, a) => {
    c(), m(u);
    let b;
    for (; !(b = a(E())); )
      m();
    return c(), b;
  };
}
function z(t, r, n = {}) {
  if (!t || typeof t != "object")
    throw new Error("expected valid options object");
  function o(i, e, s) {
    const f = t[i];
    if (s && f === void 0)
      return;
    const c = typeof f;
    if (c !== e || f === null)
      throw new Error(`param "${i}" is invalid: expected ${e}, got ${c}`);
  }
  Object.entries(r).forEach(([i, e]) => o(i, e, !1)), Object.entries(n).forEach(([i, e]) => o(i, e, !0));
}
function D(t) {
  const r = /* @__PURE__ */ new WeakMap();
  return (n, ...o) => {
    const i = r.get(n);
    if (i !== void 0)
      return i;
    const e = t(n, ...o);
    return r.set(n, e), e;
  };
}
export {
  z as _validateObject,
  $ as aInRange,
  k as abool,
  v as abytes,
  W as anumber,
  M as bitLen,
  N as bitMask,
  d as bytesToHex,
  H as bytesToNumberBE,
  O as bytesToNumberLE,
  U as concatBytes,
  R as createHmacDrbg,
  _ as ensureBytes,
  p as hexToBytes,
  h as hexToNumber,
  T as inRange,
  B as isBytes,
  D as memoized,
  x as numberToBytesBE,
  S as numberToBytesLE,
  j as numberToHexUnpadded,
  C as randomBytes,
  G as utf8ToBytes
};
