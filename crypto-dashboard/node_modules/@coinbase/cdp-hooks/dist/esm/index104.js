import { formatAbiParams as a, formatAbiItem as i } from "./index105.js";
import { size as u } from "./index106.js";
import { BaseError as r } from "./index107.js";
class m extends r {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class l extends r {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class h extends r {
  constructor({ data: e, params: t, size: o }) {
    super([`Data size of ${o} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${a(t, { includeName: !0 })})`,
        `Data:   ${e} (${o} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = t, this.size = o;
  }
}
class b extends r {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class g extends r {
  constructor({ expectedLength: e, givenLength: t, type: o }) {
    super([
      `ABI encoding array length mismatch for type ${o}.`,
      `Expected length: ${e}`,
      `Given length: ${t}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class A extends r {
  constructor({ expectedSize: e, value: t }) {
    super(`Size of bytes "${t}" (bytes${u(t)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class E extends r {
  constructor({ expectedLength: e, givenLength: t }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${t}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class y extends r {
  constructor(e, { docsPath: t }) {
    super([
      `Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).`,
      "Cannot encode error result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the inputs exist on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiErrorInputsNotFoundError"
    });
  }
}
class v extends r {
  constructor(e, { docsPath: t } = {}) {
    super([
      `Error ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiErrorNotFoundError"
    });
  }
}
class f extends r {
  constructor(e, { docsPath: t }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: t,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class x extends r {
  constructor({ docsPath: e }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: e,
      name: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class I extends r {
  constructor(e, { docsPath: t }) {
    super([
      `Encoded event signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: t,
      name: "AbiEventSignatureNotFoundError"
    });
  }
}
class $ extends r {
  constructor(e, { docsPath: t } = {}) {
    super([
      `Event ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiEventNotFoundError"
    });
  }
}
class B extends r {
  constructor(e, { docsPath: t } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class F extends r {
  constructor(e, { docsPath: t }) {
    super([
      `Function "${e}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class j extends r {
  constructor(e, { docsPath: t }) {
    super([
      `Encoded function signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: t,
      name: "AbiFunctionSignatureNotFoundError"
    });
  }
}
class M extends r {
  constructor(e, t) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${i(e.abiItem)}\`, and`,
        `\`${t.type}\` in \`${i(t.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class D extends r {
  constructor({ expectedSize: e, givenSize: t }) {
    super(`Expected bytes${e}, got bytes${t}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class w extends r {
  constructor({ abiItem: e, data: t, params: o, size: s }) {
    super([
      `Data size of ${s} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${a(o, { includeName: !0 })})`,
        `Data:   ${t} (${s} bytes)`
      ],
      name: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = e, this.data = t, this.params = o, this.size = s;
  }
}
class N extends r {
  constructor({ abiItem: e, param: t }) {
    super([
      `Expected a topic for indexed event parameter${t.name ? ` "${t.name}"` : ""} on event "${i(e, { includeName: !0 })}".`
    ].join(`
`), { name: "DecodeLogTopicsMismatch" }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = e;
  }
}
class S extends r {
  constructor(e, { docsPath: t }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: t, name: "InvalidAbiEncodingType" });
  }
}
class P extends r {
  constructor(e, { docsPath: t }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: t, name: "InvalidAbiDecodingType" });
  }
}
class k extends r {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class z extends r {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
export {
  m as AbiConstructorNotFoundError,
  l as AbiConstructorParamsNotFoundError,
  h as AbiDecodingDataSizeTooSmallError,
  b as AbiDecodingZeroDataError,
  g as AbiEncodingArrayLengthMismatchError,
  A as AbiEncodingBytesSizeMismatchError,
  E as AbiEncodingLengthMismatchError,
  y as AbiErrorInputsNotFoundError,
  v as AbiErrorNotFoundError,
  f as AbiErrorSignatureNotFoundError,
  $ as AbiEventNotFoundError,
  x as AbiEventSignatureEmptyTopicsError,
  I as AbiEventSignatureNotFoundError,
  B as AbiFunctionNotFoundError,
  F as AbiFunctionOutputsNotFoundError,
  j as AbiFunctionSignatureNotFoundError,
  M as AbiItemAmbiguityError,
  D as BytesSizeMismatchError,
  w as DecodeLogDataMismatch,
  N as DecodeLogTopicsMismatch,
  P as InvalidAbiDecodingTypeError,
  S as InvalidAbiEncodingTypeError,
  k as InvalidArrayError,
  z as InvalidDefinitionTypeError
};
