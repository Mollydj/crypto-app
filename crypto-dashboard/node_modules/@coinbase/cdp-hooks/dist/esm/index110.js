import { parseAccount as E } from "./index36.js";
import { panicReasons as $ } from "./index111.js";
import { decodeErrorResult as A } from "./index112.js";
import { formatAbiItem as y } from "./index105.js";
import { formatAbiItemWithArgs as v } from "./index113.js";
import { getAbiItem as C } from "./index114.js";
import { formatEther as P } from "./index115.js";
import { formatGwei as p } from "./index116.js";
import { AbiErrorSignatureNotFoundError as j } from "./index104.js";
import { BaseError as m } from "./index107.js";
import { prettyStateOverride as x } from "./index117.js";
import { prettyPrint as w } from "./index118.js";
import { getContractAddress as O } from "./index119.js";
class z extends m {
  constructor(e, { account: o, docsPath: u, chain: s, data: c, gas: a, gasPrice: i, maxFeePerGas: r, maxPriorityFeePerGas: t, nonce: n, to: l, value: d, stateOverride: f }) {
    const h = o ? E(o) : void 0;
    let g = w({
      from: h?.address,
      to: l,
      value: typeof d < "u" && `${P(d)} ${s?.nativeCurrency?.symbol || "ETH"}`,
      data: c,
      gas: a,
      gasPrice: typeof i < "u" && `${p(i)} gwei`,
      maxFeePerGas: typeof r < "u" && `${p(r)} gwei`,
      maxPriorityFeePerGas: typeof t < "u" && `${p(t)} gwei`,
      nonce: n
    });
    f && (g += `
${x(f)}`), super(e.shortMessage, {
      cause: e,
      docsPath: u,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Raw Call Arguments:",
        g
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class G extends m {
  constructor(e, { abi: o, args: u, contractAddress: s, docsPath: c, functionName: a, sender: i }) {
    const r = C({ abi: o, args: u, name: a }), t = r ? v({
      abiItem: r,
      args: u,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, n = r ? y(r, { includeName: !0 }) : void 0, l = w({
      address: s && O(s),
      function: n,
      args: t && t !== "()" && `${[...Array(a?.length ?? 0).keys()].map(() => " ").join("")}${t}`,
      sender: i
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${a}".`, {
      cause: e,
      docsPath: c,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        l && "Contract Call:",
        l
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = o, this.args = u, this.cause = e, this.contractAddress = s, this.functionName = a, this.sender = i;
  }
}
class H extends m {
  constructor({ abi: e, data: o, functionName: u, message: s }) {
    let c, a, i, r;
    if (o && o !== "0x")
      try {
        a = A({ abi: e, data: o });
        const { abiItem: n, errorName: l, args: d } = a;
        if (l === "Error")
          r = d[0];
        else if (l === "Panic") {
          const [f] = d;
          r = $[f];
        } else {
          const f = n ? y(n, { includeName: !0 }) : void 0, h = n && d ? v({
            abiItem: n,
            args: d,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          i = [
            f ? `Error: ${f}` : "",
            h && h !== "()" ? `       ${[...Array(l?.length ?? 0).keys()].map(() => " ").join("")}${h}` : ""
          ];
        }
      } catch (n) {
        c = n;
      }
    else s && (r = s);
    let t;
    c instanceof j && (t = c.signature, i = [
      `Unable to decode signature "${t}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`
    ]), super(r && r !== "execution reverted" || t ? [
      `The contract function "${u}" reverted with the following ${t ? "signature" : "reason"}:`,
      r || t
    ].join(`
`) : `The contract function "${u}" reverted.`, {
      cause: c,
      metaMessages: i,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "raw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = a, this.raw = o, this.reason = r, this.signature = t;
  }
}
class U extends m {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class Y extends m {
  constructor({ factory: e }) {
    super(`Deployment for counterfactual contract call failed${e ? ` for factory "${e}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class J extends m {
  constructor({ data: e, message: o }) {
    super(o || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
export {
  z as CallExecutionError,
  G as ContractFunctionExecutionError,
  H as ContractFunctionRevertedError,
  U as ContractFunctionZeroDataError,
  Y as CounterfactualDeploymentFailedError,
  J as RawContractError
};
