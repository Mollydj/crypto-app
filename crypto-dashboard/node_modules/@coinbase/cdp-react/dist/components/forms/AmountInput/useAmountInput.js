import { NumberFormatter as k } from "@internationalized/number";
import { useState as L, useCallback as n, useEffect as w, useMemo as S } from "react";
import { DEFAULT_LOCALE as T } from "../../../data/locale.js";
import { clamp as z } from "../../../utils/clamp.js";
import { useNumberParseAndFormat as B } from "./useNumberParseAndFormat.js";
const j = ({
  amount: i,
  decimalPlaces: p,
  locale: b = T,
  max: a,
  min: r,
  setAmount: g,
  onBlur: D,
  onPaste: F
}) => {
  const [s, m] = L(
    i === void 0 || isNaN(i) ? NaN : +i
  ), d = n(
    (t) => {
      m(t), g(t);
    },
    [g]
  ), [u, c] = L(
    () => isNaN(s) ? "" : new k(b, {
      maximumFractionDigits: p,
      minimumFractionDigits: 0
    }).format(s)
  ), v = n(
    (t) => r !== void 0 && a !== void 0 ? z(t, r, a) : r !== void 0 && a === void 0 ? Math.max(t, r) : r === void 0 && a !== void 0 ? Math.min(t, a) : t,
    [r, a]
  ), { parser: o, formatter: f } = B({
    inputValue: u,
    locale: b,
    options: {
      maximumFractionDigits: p,
      minimumFractionDigits: 0
    }
  }), l = n(
    (t) => {
      if (o.isValidPartialNumber(t, r, a)) {
        const e = o.parse(t);
        d(e), c(t);
      }
    },
    [a, r, o, d]
  ), h = n(
    (t) => {
      l(t.target.value);
    },
    [l]
  ), C = n(
    (t) => {
      const e = t.currentTarget;
      if ("data" in t) {
        if (!t.data) return;
        if (t.data === " ") {
          t.preventDefault();
          return;
        }
        const V = e.selectionStart || 0, N = e.selectionEnd || 0, A = e.value, M = A.slice(0, V) + t.data + A.slice(N);
        o.isValidPartialNumber(M, r, a) || t.preventDefault();
      }
    },
    [o, r, a]
  ), E = n(
    (t) => {
      if (D?.(t), !u.length) {
        d(NaN), c("");
        return;
      }
      const e = o.parse(u);
      if (isNaN(e)) {
        c(f.format(s));
        return;
      }
      const V = v(e), N = Number(V.toFixed(p));
      d(N), c(f.format(N));
    },
    [
      p,
      v,
      u,
      f,
      o,
      s,
      D,
      d
    ]
  ), I = n(
    (t) => {
      F?.(t);
      let e = t.clipboardData?.getData("text").replace(/\s/g, "");
      r !== void 0 && r >= 0 && (e = e.replace(/-/g, "")), l(e), t.preventDefault();
    },
    [r, F, l]
  );
  return w(() => {
    (i === void 0 || isNaN(i)) && isNaN(s) || i === s || (i === void 0 || isNaN(i) ? (m(NaN), c("")) : (m(i), c(f.format(i))));
  }, [i, f, s]), S(
    () => ({
      numberValue: s,
      inputValue: u,
      handleBlur: E,
      handleChange: h,
      handleBeforeInput: C,
      handlePaste: I
    }),
    [E, h, C, I, u, s]
  );
};
export {
  j as useAmountInput
};
