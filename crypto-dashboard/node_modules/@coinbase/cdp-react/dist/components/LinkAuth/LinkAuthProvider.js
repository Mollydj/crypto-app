import { jsx as m } from "react/jsx-runtime";
import { useCurrentUser as c } from "@coinbase/cdp-hooks";
import { createContext as p, useContext as M, useMemo as r, useReducer as A, useEffect as f } from "react";
import { useAppConfig as L } from "../CDPReactProvider/index.js";
import { formatPhoneNumber as k } from "../../utils/formatPhoneNumber.js";
const T = {
  methodToLink: null,
  authMethods: [],
  error: null,
  isPending: !1
}, d = p(void 0), E = (e, t) => {
  switch (t) {
    case "email":
      return {
        userAlias: e.authenticationMethods.email?.email ?? "",
        isLinked: !!e.authenticationMethods.email
      };
    case "sms":
      return {
        userAlias: e.authenticationMethods.sms?.phoneNumber ? k(e.authenticationMethods.sms?.phoneNumber) : "",
        isLinked: !!e.authenticationMethods.sms
      };
    case "oauth:google":
      return {
        userAlias: e.authenticationMethods.google?.email ?? "",
        isLinked: !!e.authenticationMethods.google
      };
    case "oauth:apple":
      return {
        userAlias: e.authenticationMethods.apple?.email ?? "",
        isLinked: !!e.authenticationMethods.apple
      };
    case "oauth:x":
      return {
        userAlias: (e.authenticationMethods.x?.username ? `@${e.authenticationMethods.x.username}` : e.authenticationMethods.x?.email) ?? "",
        isLinked: !!e.authenticationMethods.x
      };
    default:
      return null;
  }
};
function g(e, t) {
  switch (t.type) {
    case "LINK_AUTH_METHOD":
      return {
        ...e,
        error: null,
        isPending: !0,
        methodToLink: t.payload.method
      };
    case "LINK_AUTH_METHOD_ERROR":
      return {
        ...e,
        isPending: !1,
        error: t.payload.error
      };
    case "SET_AUTH_METHODS":
      return {
        ...e,
        authMethods: t.payload.methods
      };
    case "RESET_STATE":
      return {
        authMethods: e.authMethods,
        methodToLink: null,
        error: null,
        isPending: !1
      };
    default:
      throw new Error("Unknown action type");
  }
}
const y = ({ children: e }) => {
  const { currentUser: t } = c(), { authMethods: a } = L(), s = r(() => {
    const n = [];
    return a.forEach((i) => {
      if (!t) {
        n.push({
          userAlias: "",
          isLinked: !1,
          method: i
        });
        return;
      }
      const h = E(t, i);
      n.push({
        userAlias: h?.userAlias ?? "",
        isLinked: h?.isLinked ?? !1,
        method: i
      });
    }), n;
  }, [t, a]), [u, o] = A(g, {
    ...T,
    authMethods: s
  }), l = r(() => ({ state: u, dispatch: o }), [u, o]);
  return f(() => {
    o({ type: "SET_AUTH_METHODS", payload: { methods: s } });
  }, [o, s]), /* @__PURE__ */ m(d.Provider, { value: l, children: e });
}, C = () => {
  const e = M(d);
  if (!e)
    throw new Error("useLinkAuthContext must be used within a LinkAuthProvider");
  return e;
};
export {
  y as LinkAuthProvider,
  C as useLinkAuthContext
};
