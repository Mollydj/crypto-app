import { useCallback as m, useMemo as N } from "react";
import { buildPaymentMethods as R } from "../utils/buildPaymentMethods.js";
const h = ({
  country: a,
  cryptoCurrency: c,
  fetchBuyOptions: p,
  fiatCurrency: _,
  network: n,
  subdivision: u,
  dispatch: o,
  onError: t
}) => {
  const M = m(async () => {
    const d = c.toUpperCase(), T = n.toLowerCase(), g = a.toUpperCase(), y = u?.toUpperCase();
    o({ type: "FETCH_PAYMENT_METHODS" });
    try {
      const s = await p({
        country: g,
        subdivision: y
      }), r = s.purchaseCurrencies.find(
        (e) => e.symbol.toUpperCase() === d
      );
      if (!r) {
        const e = {
          errorType: "handled_error",
          code: "INVALID_PURCHASE_CURRENCY",
          debugMessage: `You cannot purchase ${d} in your region.`
        };
        t?.(e), o({
          type: "SET_PAYMENT_METHODS_ERROR",
          payload: {
            error: {
              code: e?.code,
              message: e?.debugMessage
            }
          }
        });
        return;
      }
      if (!r.networks.find(
        (e) => e.name.toLowerCase() === T
      )) {
        const e = {
          errorType: "handled_error",
          code: "INVALID_NETWORK",
          debugMessage: `You cannot purchase ${d} on ${n} in your region.`
        };
        t?.(e), o({
          type: "SET_PAYMENT_METHODS_ERROR",
          payload: {
            error: {
              code: e?.code,
              message: e?.debugMessage
            }
          }
        });
        return;
      }
      const E = R(s, _, a);
      if (E.length === 0) {
        const e = {
          errorType: "handled_error",
          code: "NO_PAYMENT_METHODS",
          debugMessage: "No payment methods found for the selected country and currency."
        };
        t?.(e), o({
          type: "SET_PAYMENT_METHODS_ERROR",
          payload: {
            error: {
              code: e?.code,
              message: e?.debugMessage
            }
          }
        });
        return;
      }
      o({ type: "SET_PAYMENT_METHODS_SUCCESS", payload: { paymentMethods: E } });
    } catch (s) {
      let r;
      s instanceof Error ? r = {
        errorType: "handled_error",
        code: "PAYMENT_METHODS_ERROR",
        debugMessage: s.message
      } : r = {
        errorType: "unknown_error",
        code: "UNKNOWN_PAYMENT_METHODS_ERROR",
        debugMessage: JSON.stringify(s)
      }, t?.(r), o({
        type: "SET_PAYMENT_METHODS_ERROR",
        payload: {
          error: {
            code: r?.code,
            message: r.errorType === "handled_error" ? r?.debugMessage : "Something went wrong fetching the payment methods"
          }
        }
      });
    }
  }, [
    a,
    c,
    o,
    p,
    _,
    n,
    t,
    u
  ]);
  return N(() => ({ fetchPaymentMethods: M }), [M]);
};
export {
  h as usePaymentMethods
};
