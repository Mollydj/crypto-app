import { CSSProperties, Dispatch, ReactNode } from 'react';
import { InputType } from '../forms/ExchangeAmountInput/types';
import { FetchBuyUrlParams } from './hooks/useBuyUrl';
export type CamelToSnakeCase<T extends string> = T extends `${infer A}${infer B}` ? B extends Uncapitalize<B> ? `${A}${CamelToSnakeCase<B>}` : `${Uncapitalize<A>}_${CamelToSnakeCase<Uncapitalize<B>>}` : T;
export type CamelToSnakeCaseNested<T> = T extends readonly any[] ? T : T extends object ? {
    [K in keyof T as K extends string ? CamelToSnakeCase<K> : K]: CamelToSnakeCaseNested<T[K]>;
} : T;
export type FundPresetAmountInputs = readonly [number, number, number];
export interface FundPaymentMethod {
    id: string;
    name: string;
    description: string;
    icon: ReactNode;
    minAmount?: number;
    maxAmount?: number;
}
export type OnrampOpenEvent = {
    eventName: "open";
    widgetName: string;
};
export type OnrampTransitionViewEvent = {
    eventName: "transition_view";
    pageRoute: string;
};
export type OnrampPublicErrorEvent = {
    eventName: "error";
    error: OnrampError;
};
export type OnrampExitEvent = {
    eventName: "exit";
    error?: OnrampError;
};
export type OnrampSuccessEvent = {
    eventName: "success";
    data?: OnrampSuccessEventData;
};
export type OnrampSuccessEventData = {
    assetImageUrl: string;
    assetName: string;
    assetSymbol: string;
    chainId: string;
};
export type RequestOpenUrlEvent = {
    eventName: "request_open_url";
    url: string;
};
export type EventMetadata = OnrampOpenEvent | OnrampTransitionViewEvent | OnrampPublicErrorEvent | OnrampExitEvent | OnrampSuccessEvent | RequestOpenUrlEvent;
export interface OnrampError {
    errorType: "internal_error" | "handled_error" | "network_error" | "unknown_error";
    code?: string;
    debugMessage?: string;
}
export type FundLifecycleStatus = {
    statusName: "init";
    statusData: null;
} | {
    statusName: "exit";
    statusData: null;
} | {
    statusName: "error";
    statusData: OnrampError;
} | {
    statusName: "transactionSubmitted";
    statusData: null;
} | {
    statusName: "transactionSuccess";
    statusData: OnrampSuccessEventData | null;
} | {
    statusName: "transactionPending";
    statusData: null;
};
export type FundTxResolution = Extract<FundLifecycleStatus["statusName"], "transactionSubmitted" | "transactionSuccess" | "error"> | null;
export type FundLifecycleEvents = {
    onError?: (e: OnrampError | undefined) => void;
    onStatus?: (lifecycleStatus: FundLifecycleStatus) => void;
    onSuccess?: (result?: OnrampSuccessEventData) => void;
};
export type FundStateError = {
    code: string;
    message: string;
};
export interface FundState {
    country: string;
    cryptoAmount?: number;
    cryptoCurrency: string;
    cryptoDecimalPlaces?: number;
    exchangeRate?: number;
    exchangeRateError?: FundStateError | null;
    isExchangeRatePending?: boolean;
    isPaymentMethodsPending?: boolean;
    fiatAmount?: number;
    fiatCurrency: string;
    fiatDecimalPlaces?: number;
    locale?: string;
    network: string;
    paymentMethods?: FundPaymentMethod[];
    paymentMethodsError?: FundStateError | null;
    presetAmountInputs?: FundPresetAmountInputs;
    selectedInputType: InputType;
    selectedPaymentMethod?: FundPaymentMethod;
    subdivision?: string;
    transactionStatus: FundLifecycleStatus;
    destinationAddress: string;
}
export type FundStateProps = Pick<FundState, "country" | "cryptoCurrency" | "cryptoDecimalPlaces" | "fiatCurrency" | "fiatDecimalPlaces" | "locale" | "network" | "presetAmountInputs" | "subdivision" | "destinationAddress">;
export interface FundProps extends FundStateProps, FundLifecycleEvents {
    children?: ReactNode | ((state: FundState) => ReactNode);
    className?: string;
    fetchBuyOptions: FetchBuyOptions;
    fetchBuyQuote: FetchBuyQuote;
    inputType?: InputType;
    openIn?: "popup" | "tab";
    redirectUrl?: string;
    style?: CSSProperties;
    submitLabel?: ReactNode;
    title?: ReactNode;
}
export type FundAction = {
    type: "SET_FIELD";
    payload: {
        [K in keyof FundState]: {
            field: K;
            value: FundState[K];
        };
    }[keyof FundState];
} | {
    type: "SET_AMOUNTS";
    payload: {
        cryptoAmount: number;
        fiatAmount: number;
    };
} | {
    type: "FETCH_EXCHANGE_RATE";
} | {
    type: "SET_EXCHANGE_RATE_SUCCESS";
    payload: {
        exchangeRate: number | undefined;
    };
} | {
    type: "SET_EXCHANGE_RATE_ERROR";
    payload: {
        error: Partial<NonNullable<FundState["exchangeRateError"]>>;
    };
} | {
    type: "FETCH_PAYMENT_METHODS";
} | {
    type: "SET_PAYMENT_METHODS_SUCCESS";
    payload: {
        paymentMethods: FundPaymentMethod[];
    };
} | {
    type: "SET_PAYMENT_METHODS_ERROR";
    payload: {
        error: Partial<NonNullable<FundState["paymentMethodsError"]>>;
    };
} | {
    type: "SET_TRANSACTION_STATUS";
    payload: {
        transactionStatus: FundLifecycleStatus;
    };
} | {
    type: "SYNC_WITH_PROPS";
    payload: FundStateProps;
};
export type FundContextType = {
    state: FundState;
    dispatch: Dispatch<FundAction>;
    fetchBuyUrl: (params: FetchBuyUrlParams, onError?: (e: OnrampError | undefined) => void) => Promise<string>;
};
export type OnrampPaymentMethodLimit = {
    id: string;
    min: string;
    max: string;
};
export type OnrampPaymentCurrency = {
    id: string;
    limits: OnrampPaymentMethodLimit[];
};
export type OnrampNetwork = {
    name: string;
    displayName: string;
    chainId: string;
    contractAddress: string;
    iconUrl: string;
};
export type OnrampPurchaseCurrency = {
    id: string;
    name: string;
    symbol: string;
    iconUrl: string;
    networks: OnrampNetwork[];
};
export type OnrampAmount = {
    value: string;
    currency: string;
};
export type OnrampBuyOptionsResponse = {
    paymentCurrencies: OnrampPaymentCurrency[];
    purchaseCurrencies: OnrampPurchaseCurrency[];
};
export type OnrampBuyOptionsSnakeCaseResponse = CamelToSnakeCaseNested<OnrampBuyOptionsResponse>;
export type OnrampBuyQuoteResponse = {
    paymentTotal: OnrampAmount;
    paymentSubtotal: OnrampAmount;
    purchaseAmount: OnrampAmount;
    coinbaseFee: OnrampAmount;
    networkFee: OnrampAmount;
    quoteId: string;
    onrampUrl?: string;
};
export type OnrampBuyQuoteSnakeCaseResponse = CamelToSnakeCaseNested<OnrampBuyQuoteResponse>;
export type FetchBuyOptions = (params: {
    country: string;
    subdivision?: string;
}) => Promise<OnrampBuyOptionsResponse>;
export type FetchBuyQuote = (params: {
    destinationAddress: string;
    purchaseCurrency: string;
    purchaseNetwork: string;
    paymentAmount: string;
    paymentCurrency: string;
    paymentMethod: string;
    country: string;
    subdivision?: string;
}) => Promise<OnrampBuyQuoteResponse>;
