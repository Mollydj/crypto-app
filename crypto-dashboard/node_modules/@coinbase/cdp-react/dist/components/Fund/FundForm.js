import { jsx as r, jsxs as H } from "react/jsx-runtime";
import { useRef as c, useState as h, useCallback as s, useEffect as y, useMemo as J } from "react";
import { Button as Y } from "../ui/Button/index.js";
import { SwitchFadeTransition as Q } from "../ui/SwitchFadeTransition/index.js";
import { useTimer as X } from "../../hooks/useTimer.js";
import { formatFiat as w } from "../../utils/formatFiat.js";
import { openPopup as Z } from "../../utils/openPopup.js";
import { FundAmountInput as tt } from "./components/FundAmountInput.js";
import { FundErrorScreen as et } from "./components/FundErrorScreen.js";
import { FundPaymentMethods as rt } from "./components/FundPaymentMethods.js";
import { FundPresetAmountInputs as nt } from "./components/FundPresetAmountInputs.js";
import { FundTransactionStatus as ot } from "./components/FundTransactionStatus.js";
import { useFundContext as st } from "./FundProvider.js";
import { usePopupMonitor as it } from "./hooks/usePopupMonitor.js";
import '../../assets/FundForm.css';const at = "FundForm-module__view___5V1qO", ut = "FundForm-module__form___TIzVJ", B = {
  view: at,
  form: ut
}, mt = ["form", "error", "transaction-status"], Ft = ({
  className: T = "",
  children: A,
  onPopupClose: N,
  onPopupOpen: S,
  onSubmit: I,
  openIn: V,
  submitLabel: D,
  unmountOnTransactionError: d = !1,
  unmountOnTransactionSuccess: p = !1,
  unmount: a,
  ...$
}) => {
  const { state: t, dispatch: M, fetchBuyUrl: P } = st(), g = c(t.fiatAmount === void 0 ? NaN : t.fiatAmount), [k, _] = h(!1), [j, F] = h(!1), E = c(null), [K, L] = h(null), b = c(null), U = c(null), u = c(null), l = s(
    (e) => (e === "transactionSuccess" || e === "transactionSubmitted") && p || e === "error" && d,
    [p, d]
  ), {
    timeRemaining: f,
    start: v,
    reset: C
  } = X(), n = s((e) => {
    U.current !== e && (U.current = e, b.current?.transition.toggle(e));
  }, []), m = s(() => {
    a && l(u.current) ? a() : n("form"), u.current = null, M({
      type: "SET_TRANSACTION_STATUS",
      payload: { transactionStatus: { statusName: "init", statusData: null } }
    });
  }, [n, M, a, l]), O = s(() => {
    a && l(u.current) ? v(3) : u.current === null && m(), N?.();
  }, [v, N, m, a, l]);
  y(() => {
    f !== null && f <= 0 && (m(), C());
  }, [f, m, C]), y(() => {
    (t.transactionStatus.statusName === "transactionSubmitted" || t.transactionStatus.statusName === "transactionSuccess" || t.transactionStatus.statusName === "error") && (u.current = t.transactionStatus.statusName);
  }, [t.transactionStatus.statusName]), y(() => {
    t.paymentMethodsError?.message && n("error");
  }, [t.paymentMethodsError?.message, n]);
  const { startPopupMonitor: R } = it(O), W = s(
    (e) => {
      e && (n("transaction-status"), R(e), S?.(e));
    },
    [S, R, n]
  ), q = s(() => {
    (t.fiatAmount === void 0 || isNaN(t.fiatAmount)) && isNaN(g.current) || t.fiatAmount === g.current || _(!0);
  }, [t.fiatAmount]), x = J(() => {
    if (t.fiatAmount === void 0 || isNaN(t.fiatAmount))
      return "Enter an amount";
    if (t.fiatAmount < (t.selectedPaymentMethod?.minAmount ?? 0))
      return `Minimum amount is ${w(t.selectedPaymentMethod?.minAmount ?? 0, t.fiatCurrency, t.fiatDecimalPlaces, t.locale)}`;
    if (t.selectedPaymentMethod?.maxAmount !== void 0 && t.fiatAmount > t.selectedPaymentMethod.maxAmount)
      return `Maximum amount is ${w(t.selectedPaymentMethod?.maxAmount, t.fiatCurrency, t.fiatDecimalPlaces, t.locale)}`;
  }, [
    t.fiatAmount,
    t.fiatCurrency,
    t.fiatDecimalPlaces,
    t.locale,
    t.selectedPaymentMethod?.minAmount,
    t.selectedPaymentMethod?.maxAmount
  ]), z = s(async () => {
    if (!(t.fiatAmount === void 0 || isNaN(t.fiatAmount) || !t.selectedPaymentMethod?.id))
      return P(
        {
          paymentMethod: t.selectedPaymentMethod?.id,
          paymentAmount: t.fiatAmount
        },
        (e) => {
          L({
            code: e?.code || "UNKNOWN_BUY_URL_ERROR",
            message: e?.debugMessage || "Something went wrong fetching the buy url"
          }), n("error");
        }
      );
  }, [t.fiatAmount, t.selectedPaymentMethod?.id, P, n]), G = async (e) => {
    if (e.preventDefault(), x) {
      _(!0), E.current?.focus();
      return;
    }
    I?.(e), F(!0);
    const i = await z();
    if (F(!1), i)
      if (V === "tab")
        window.open(i, "_blank");
      else {
        const o = Z({ url: i, width: 460, height: 720 });
        W(o);
      }
  };
  return /* @__PURE__ */ r(
    Q,
    {
      animateHeight: !0,
      timeout: 250,
      items: mt,
      initialEntered: !0,
      transitionRef: b,
      children: ({ itemKey: e, ...i }) => {
        let o = null;
        return e === "form" && (o = /* @__PURE__ */ H("form", { className: `${B.form} ${T}`, onSubmit: G, ...$, children: [
          /* @__PURE__ */ r("div", { children: /* @__PURE__ */ r(
            tt,
            {
              ref: E,
              error: k ? x : void 0,
              onBlur: q
            }
          ) }),
          /* @__PURE__ */ r(nt, {}),
          /* @__PURE__ */ r(rt, {}),
          /* @__PURE__ */ r(
            Y,
            {
              variant: "primary",
              type: "submit",
              isPending: j,
              pendingLabel: "Getting purchase link",
              children: D || "Deposit"
            }
          )
        ] })), e === "error" && (o = /* @__PURE__ */ r(et, { error: t.paymentMethodsError || K })), e === "transaction-status" && (o = /* @__PURE__ */ r(
          ot,
          {
            unmountOnSuccess: p,
            unmountOnError: d,
            reset: m,
            timeRemaining: f
          }
        )), /* @__PURE__ */ r("div", { ...i, className: B.view, children: A ? A({ view: e, Content: o }) : o });
      }
    }
  );
};
export {
  Ft as FundForm,
  mt as VIEWS
};
