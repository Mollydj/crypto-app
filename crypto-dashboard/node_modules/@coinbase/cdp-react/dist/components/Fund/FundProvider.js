import { jsx as A } from "react/jsx-runtime";
import { createContext as E, useContext as R, useEffect as f, useMemo as b } from "react";
import { useBuyUrl as M } from "./hooks/useBuyUrl.js";
import { useEmitLifecycleStatus as g } from "./hooks/useEmitLifecycleStatus.js";
import { useExchangeRate as k } from "./hooks/useExchangeRate.js";
import { usePaymentMethods as H } from "./hooks/usePaymentMethods.js";
import { useFundReducer as N } from "./useFundReducer.js";
const h = {
  country: "US",
  cryptoCurrency: "ETH",
  cryptoDecimalPlaces: 8,
  fiatCurrency: "USD",
  fiatDecimalPlaces: 2,
  network: "base",
  presetAmountInputs: void 0,
  selectedInputType: "fiat",
  transactionStatus: {
    statusName: "init",
    statusData: null
  },
  destinationAddress: ""
}, S = E(void 0), q = ({
  children: c,
  fetchBuyOptions: v,
  fetchBuyQuote: y,
  inputType: D,
  onError: u,
  onStatus: F,
  onSuccess: I,
  ...w
}) => {
  const {
    country: t,
    cryptoCurrency: e,
    cryptoDecimalPlaces: i,
    fiatCurrency: s,
    fiatDecimalPlaces: d,
    locale: m,
    network: n,
    presetAmountInputs: p,
    redirectUrl: T,
    subdivision: o,
    destinationAddress: a
  } = w, [l, r] = N({
    ...h,
    country: t,
    cryptoCurrency: e,
    cryptoDecimalPlaces: i,
    fiatCurrency: s,
    fiatDecimalPlaces: d,
    locale: m,
    network: n,
    presetAmountInputs: p,
    subdivision: o,
    destinationAddress: a,
    selectedInputType: D || h.selectedInputType
  });
  f(() => {
    r({
      type: "SYNC_WITH_PROPS",
      payload: {
        country: t,
        cryptoCurrency: e,
        cryptoDecimalPlaces: i,
        fiatCurrency: s,
        fiatDecimalPlaces: d,
        locale: m,
        network: n,
        presetAmountInputs: p,
        subdivision: o,
        destinationAddress: a
      }
    });
  }, [
    t,
    e,
    i,
    s,
    d,
    m,
    n,
    p,
    o,
    r,
    a
  ]), g({
    lifecycleStatus: l.transactionStatus,
    onError: u,
    onStatus: F,
    onSuccess: I
  });
  const { fetchExchangeRate: P } = k({
    cryptoCurrency: e,
    country: t,
    dispatch: r,
    fetchBuyQuote: y,
    fiatCurrency: s,
    network: n,
    onError: u,
    subdivision: o
  }), { fetchPaymentMethods: x } = H({
    country: t,
    cryptoCurrency: e,
    dispatch: r,
    fetchBuyOptions: v,
    fiatCurrency: s,
    network: n,
    onError: u,
    subdivision: o
  }), { fetchBuyUrl: C } = M({
    cryptoCurrency: e,
    fiatCurrency: s,
    fetchBuyQuote: y,
    country: t,
    network: n,
    redirectUrl: T,
    subdivision: o,
    destinationAddress: a
  }), U = b(() => ({ state: l, dispatch: r, fetchBuyUrl: C }), [l, r, C]);
  return f(() => {
    P();
  }, [P]), f(() => {
    x();
  }, [x]), /* @__PURE__ */ A(S.Provider, { value: U, children: c });
}, z = () => {
  const c = R(S);
  if (!c)
    throw new Error("useFundContext must be used within a FundProvider");
  return c;
};
export {
  q as FundProvider,
  z as useFundContext
};
