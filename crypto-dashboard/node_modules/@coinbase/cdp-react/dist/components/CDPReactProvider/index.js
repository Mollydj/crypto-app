import { jsx as p, jsxs as H } from "react/jsx-runtime";
import { OAuth2ProviderType as S, CDPContext as U, CDPHooksProvider as _ } from "@coinbase/cdp-hooks";
import { lazy as E, createContext as j, useContext as m, useMemo as L } from "react";
import { ThemeProvider as F } from "../ThemeProvider/index.js";
const k = E(() => import("../OAuthStatusModal/index.js")), I = (t) => {
  try {
    return JSON.stringify(t);
  } catch {
  }
  return "";
}, J = Object.keys(S).map((t) => `oauth:${t}`), V = [
  /** Email OTP method */
  "email",
  /** SMS OTP method */
  "sms"
], G = [...V, ...J], K = ({
  children: t,
  className: r = "",
  config: n,
  name: s,
  style: a,
  theme: i
}) => {
  const {
    appName: h,
    appLogoUrl: c,
    showCoinbaseFooter: u,
    authMethods: e,
    projectId: d,
    secureIframeBasePath: C,
    useMock: l,
    debugging: f,
    basePath: A,
    ethereum: y,
    solana: b,
    disableAnalytics: O,
    customAuth: P
  } = n, { createOnLogin: M } = y ?? {}, { createOnLogin: v } = b ?? {}, w = L(
    () => ({
      projectId: d,
      useMock: l,
      debugging: f,
      basePath: A,
      secureIframeBasePath: C,
      disableAnalytics: O,
      customAuth: P,
      ethereum: { createOnLogin: M },
      solana: { createOnLogin: v }
    }),
    [
      d,
      l,
      f,
      A,
      C,
      M,
      v,
      O,
      P
    ]
  ), N = { appName: h, appLogoUrl: c, showCoinbaseFooter: u, authMethods: e }, T = e?.some((D) => D.startsWith("oauth:")), x = /* @__PURE__ */ p(z, { name: s, config: N, children: /* @__PURE__ */ H(F, { className: r, style: a, theme: i, children: [
    t,
    T && /* @__PURE__ */ p(k, {})
  ] }) });
  return m(U) ? x : /* @__PURE__ */ p(_, { config: w, children: x });
}, g = j(
  void 0
), o = {
  appName: "",
  appLogoUrl: "",
  showCoinbaseFooter: !0,
  authMethods: ["email"]
}, z = ({
  children: t,
  config: r,
  name: n
}) => {
  const {
    appName: s = o.appName,
    appLogoUrl: a = o.appLogoUrl,
    showCoinbaseFooter: i = o.showCoinbaseFooter,
    authMethods: h = o.authMethods
  } = r ?? {}, c = I(h), u = L(() => {
    let e = ["email"];
    try {
      e = JSON.parse(c);
    } catch {
    }
    return {
      app: {
        appName: s,
        appLogoUrl: a,
        showCoinbaseFooter: i,
        authMethods: Array.isArray(e) && e?.length ? e : o.authMethods
      },
      name: n
    };
  }, [s, a, i, c, n]);
  return /* @__PURE__ */ p(g.Provider, { value: u, children: t });
}, Q = () => {
  const t = m(g);
  if (!t)
    throw new Error("useAppConfig must be used within an AppConfigProvider");
  return t.app;
}, X = () => {
  const t = m(g);
  if (!t)
    throw new Error("useProviderName must be used within an AppConfigProvider");
  return t.name ?? "";
};
export {
  G as ALL_AUTH_METHODS,
  V as AUTH_METHODS,
  K as CDPReactProvider,
  J as OAUTH_METHODS,
  Q as useAppConfig,
  X as useProviderName
};
