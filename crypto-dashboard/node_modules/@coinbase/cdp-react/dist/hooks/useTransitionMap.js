import { useState as F, useRef as h, useCallback as u } from "react";
import { getTimeout as q, getEndStatus as z, getState as B, PRE_EXIT as D, nextTick as H, PRE_ENTER as C, EXITING as V, ENTERING as j, ENTERED as A, startOrEnd as G } from "../utils/transition.js";
const w = (f, s, l, c, o, E) => {
  o && (clearTimeout(o), cancelAnimationFrame(o));
  const p = B(s), a = new Map(c.current);
  a.set(f, p), l(a), c.current = a, E?.({ key: f, current: p });
}, L = (f = {}) => {
  const {
    allowMultiple: s,
    enter: l = !0,
    exit: c = !0,
    preEnter: o,
    preExit: E,
    timeout: p = 200,
    initialEntered: a,
    mountOnEnter: _,
    unmountOnExit: m,
    onStateChange: d
  } = f, [x, g] = F(/* @__PURE__ */ new Map()), n = h(x), T = h(/* @__PURE__ */ new Map()), [I, O] = q(p), P = u(
    (t, e) => {
      const { initialEntered: i = a } = e || {}, r = i ? A : G(_ ?? !1);
      w(t, r, g, n), T.current.set(t, {});
    },
    [a, _]
  ), X = u((t) => {
    const e = new Map(n.current);
    return e.delete(t) ? (g(e), n.current = e, T.current.delete(t), !0) : !1;
  }, []), M = u(
    (t) => {
      const e = n.current.get(t);
      if (!e) {
        process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && console.error(`[React-Transition-State] invalid key: ${t}`);
        return;
      }
      const { timerId: i } = T.current.get(t) ?? {}, r = z(e._s, m ?? !1);
      r && w(t, r, g, n, i, d);
    },
    [d, m]
  ), N = u(
    (t, e) => {
      const i = n.current.get(t);
      if (!i) {
        process.env.NODE_ENV !== "production" && console.error(`[React-Transition-State] invalid key: ${t}`);
        return;
      }
      const r = T.current.get(t), R = (S) => {
        switch (w(t, S, g, n, r.timerId, d), S) {
          case j:
            I >= 0 && (r.timerId = setTimeout(() => M(t), I));
            break;
          case V:
            O >= 0 && (r.timerId = setTimeout(() => M(t), O));
            break;
          case C:
          case D:
            r.timerId = H(R, S);
            break;
        }
      }, b = i.isEnter;
      typeof e != "boolean" && (e = !b), e ? b || (R(l ? o ? C : j : A), s || n.current.forEach((S, v) => v !== t && N(v, !1))) : b && R(c ? E ? D : V : G(m ?? !1));
    },
    [
      d,
      M,
      s,
      l,
      c,
      o,
      E,
      I,
      O,
      m
    ]
  ), $ = u(
    (t) => {
      if (!(!s && t !== !1))
        for (const e of n.current.keys()) N(e, t);
    },
    [s, N]
  );
  return {
    stateMap: x,
    toggle: N,
    toggleAll: $,
    endTransition: M,
    setItem: P,
    deleteItem: X
  };
};
export {
  L as useTransitionMap
};
